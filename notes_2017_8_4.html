<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>notes_2017_8_4</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h1 id="第1月第2周笔记整理">第1月第2周笔记整理</h1>

<hr>

<p><div class="toc">
<ul>
<li><a href="#第1月第2周笔记整理">第1月第2周笔记整理</a><ul>
<li><a href="#中断与中断处理">中断与中断处理</a><ul>
<li><a href="#何为中断">何为中断？</a></li>
<li><a href="#中断处理程序">中断处理程序</a><ul>
<li><a href="#中断处理程序注册">中断处理程序注册</a></li>
</ul>
</li>
<li><a href="#中断处理程序释放">中断处理程序释放</a></li>
<li><a href="#编写中断处理程序">编写中断处理程序</a></li>
</ul>
</li>
<li><a href="#中断上下文">中断上下文</a><ul>
<li><a href="#中断控制">中断控制</a></li>
</ul>
</li>
<li><a href="#下半部笔记">下半部笔记</a><ul>
<li><a href="#1-软中断">1. 软中断</a><ul>
<li><a href="#软中断实现">软中断实现</a></li>
<li><a href="#软中断处理程序">软中断处理程序</a></li>
<li><a href="#软中断的执行">软中断的执行</a></li>
<li><a href="#软中断的使用">软中断的使用</a><ul>
<li><a href="#1分配索引">1）分配索引</a></li>
<li><a href="#2注册处理程序">2）注册处理程序</a></li>
<li><a href="#3触发中断">3）触发中断</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2tasklet">2.tasklet</a><ul>
<li><a href="#tasklet实现">tasklet实现</a><ul>
<li><a href="#tasklet结构">tasklet结构</a></li>
<li><a href="#调度">调度</a></li>
</ul>
</li>
<li><a href="#使用tasklet">使用tasklet</a><ul>
<li><a href="#1-声明自己的tasklet">1) 声明自己的tasklet</a></li>
<li><a href="#2-编写tasklet处理程序">2） 编写tasklet处理程序</a></li>
<li><a href="#3调度自己的tasklet">3)调度自己的tasklet</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#工作队列">工作队列</a><ul>
<li><a href="#实现">实现</a><ul>
<li><a href="#数据结构">数据结构</a></li>
</ul>
</li>
<li><a href="#使用工作队列">使用工作队列</a><ul>
<li><a href="#1创建推后的工作">1）创建推后的工作</a></li>
<li><a href="#2工作队列处理函数">2）工作队列处理函数</a></li>
</ul>
</li>
<li><a href="#3对工作进行调度">3）对工作进行调度</a><ul>
<li><a href="#4刷新操作">4）刷新操作</a></li>
<li><a href="#5创建新的工作队列">5）创建新的工作队列</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#linux内核同步笔记">Linux内核同步笔记</a><ul>
<li><a href="#几个基本概念">几个基本概念</a></li>
<li><a href="#预防死锁">预防死锁</a></li>
<li><a href="#原子操作">原子操作</a><ul>
<li><a href="#原子整数操作">原子整数操作</a></li>
<li><a href="#64位整数的原子操作">64位整数的原子操作</a></li>
<li><a href="#原子位操作">原子位操作</a></li>
</ul>
</li>
<li><a href="#自旋锁">自旋锁</a><ul>
<li><a href="#自旋锁方法">自旋锁方法</a></li>
</ul>
</li>
<li><a href="#读写自旋锁">读写自旋锁</a></li>
<li><a href="#信号量">信号量</a><ul>
<li><a href="#计数信号量和二值信号量">计数信号量和二值信号量</a></li>
<li><a href="#创建和初始化信号量">创建和初始化信号量</a></li>
<li><a href="#使用信号量">使用信号量</a></li>
</ul>
</li>
<li><a href="#读写信号量">读写信号量</a></li>
<li><a href="#互斥体mutex">互斥体（mutex）</a></li>
<li><a href="#完成变量completion-variable">完成变量（completion variable）</a></li>
<li><a href="#顺序锁">顺序锁</a></li>
<li><a href="#禁止抢占">禁止抢占</a></li>
<li><a href="#顺序和屏障">顺序和屏障</a></li>
</ul>
</li>
<li><a href="#crt0smain代码分析">crt0,S(_main)代码分析</a><ul>
<li><a href="#1-设置sp寄存器地址">1. 设置sp寄存器地址</a></li>
<li><a href="#2-在栈中为全局变量gd分配空间">2. 在栈中为全局变量gd分配空间</a></li>
<li><a href="#3-在栈中gd空间清零">3. 在栈中gd空间清零</a></li>
<li><a href="#4-调用boardinitf初始化各种硬件">4. 调用board_init_f，初始化各种硬件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</p>

<hr>

<h2 id="中断与中断处理">中断与中断处理</h2>



<h3 id="何为中断">何为中断？</h3>

<ul>
<li>一种由设备发向处理器的电信号</li>
<li>中断不与处理器时钟同步，随时可以发生，内核随时可能因为中断到来而被打断。</li>
<li>每一个中断都有唯一一个数字标志，称之为中断线（IRQ）</li>
<li>异常是由软件产生，与处理器时钟同步。</li>
</ul>



<h3 id="中断处理程序">中断处理程序</h3>

<ul>
<li>由内核调用来响应中断</li>
<li>运行于中断上下文</li>
<li>中断的执行不可阻塞</li>
<li>中断处理分为两个部分，中断处理程序是上半部（top half），还有下半部（bottom halves）</li>
</ul>



<h4 id="中断处理程序注册">中断处理程序注册</h4>

<ul>
<li>中断处理程序是管理硬件驱动程序的组成部分，如果设备使用中断，其相应的驱动程序就会注册一个中断处理程序。</li>
<li>通过request_irq（）函数来注册中断处理程序</li>
</ul>



<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span> request_ir<span class="hljs-string">q( unsigned irq,
        irq_handler_t handler,
        unsigned long flags,
        count char* name,
        void <span class="hljs-variable">*dev</span>)</span></code></pre>

<ul>
<li>第一个参数irq表示要分配的中断号</li>
<li>第二个参数handler表示中断处理程序指针</li>
<li>第三个表示标志，可以为0、IRQF_DISABLE、IRQF_SAMPLE_RANDOM、IRQF_TIMER、IRQF_SHARED <br>
<ul><li><strong>IRQF_DISABLE</strong> 表示该中断处理期间，禁用所有其他中断</li>
<li><strong>IRQF_SAMPLE_RANDOM</strong> 这个设备产生的中断对内核熵池有贡献</li>
<li><strong>IRQF_TIMER</strong> 为系统定时器中断而准备的</li>
<li><strong>IRQF_SHARED</strong> 表示多个中断处理程序共享中断线。</li></ul></li>
<li>第四个参数name表示设备的文本表示</li>
<li><p>第五个参数dev用于共享中断线，dev提供唯一的标志信息。</p>

<p>需要注意的是，request_irq( )可能睡眠，因此不能再中断上下文或者其他不允许阻塞的代码中调用该函数。</p></li>
</ul>



<h3 id="中断处理程序释放">中断处理程序释放</h3>

<p>卸载驱动程序时，需要用<strong>free_irq（）</strong>注销相应的中断处理程序，并释放中断线。</p>



<pre class="prettyprint"><code class=" hljs perl">  void free_ir<span class="hljs-string">q(unsigned int irq, void <span class="hljs-variable">*dev</span>)</span>;</code></pre>

<p>如果指定的中断线不是共享的，那么该函数删除处理程序的同时将禁用这条中断线。如果是共享的，只删除dev对应的中断处理程序。</p>



<h3 id="编写中断处理程序">编写中断处理程序</h3>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">static</span> irqreturn_t intr_handler(<span class="hljs-keyword">int</span> irq, <span class="hljs-keyword">void</span> * dev);</code></pre>

<p>当一个给定的中断处理程序正在执行时，相应的中断线在所有的处理器上都会被屏蔽掉，以防止在同一条中断线上接受另一个新的中断。</p>



<h2 id="中断上下文">中断上下文</h2>

<ul>
<li>当执行一个中断时，内核处于中断上下文。</li>
<li>中断上下文没有后备进程，不可以睡眠。</li>
<li>中断上下文有着严格的时间限制，因为其打断了其他代码（有可能打断了其他中断处理程序）。中断上下文中的 代码应该迅速简洁，尽量不要使用循环去处理繁重的工作。</li>
</ul>



<h3 id="中断控制">中断控制</h3>

<p>Linux内核提供了一组接口用于控制机器上的中断状态</p>

<ul>
<li>禁止和激活中断 <br>
用于禁止、激活当前处理器的本地中断，</li>
</ul>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">local_irq_disable()</span>;
<span class="hljs-function">local_irqenable()</span>;</code></pre>

<ul>
<li>禁止指定中断线</li>
</ul>



<pre class="prettyprint"><code class=" hljs perl">void disable_ir<span class="hljs-string">q(unsigned int irq)</span>;         <span class="hljs-regexp">//</span>禁止控制器上某一条中断线，函数只有在当前执行的所有处理程序完成后，才能返回 
void disable_irq_nosync(unsigned <span class="hljs-keyword">int</span> irq);  <span class="hljs-regexp">//</span>禁止控制器上某一条中断线，不会等待当前中断处理程序执行完毕。
void enable_ir<span class="hljs-string">q(unsigned int irq)</span>;          <span class="hljs-regexp">//</span>激活控制器上某一条中断线， 
void synchronize_ir<span class="hljs-string">q(unsigned int irq)</span>;     <span class="hljs-regexp">//</span>等待下一个特定的中断处理程序退出</code></pre>

<p>在一条中断线上，每次调用disable_irq_nosync()、disable_irq()，都需要调用一次enable_irq()，只有在enable_irq()完成了最后一次调用后，才完成了中断线的激活。</p>

<ul>
<li>这三个函数可以从中断或进程上下文中调用，而且不会睡眠。</li>
</ul>



<h2 id="下半部笔记">下半部笔记</h2>

<hr>



<h3 id="1-软中断">1. 软中断</h3>



<h4 id="软中断实现">软中断实现</h4>

<p>软中断是在编译期间静态分配，其结构如下所示，结构中包含一个接受该结构体指针作为参数的action函数。</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">struct</span> softirq_action{
    <span class="hljs-keyword">void</span> (*action)(<span class="hljs-keyword">struct</span> softirq_action *);
}</code></pre>

<p>在kernel/softirq.c中定义了一个包含32个结构体的数组，每个数组成员都是一个被注册的软中断，数组如下所示：</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> softirq_action softirq_vec[NR_SOFTIRQS];</code></pre>



<h4 id="软中断处理程序">软中断处理程序</h4>

<p>软中断处理函数action原型如下：</p>



<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">void</span> siftirq_handler(<span class="hljs-keyword">struct</span> softirq_action *);</code></pre>

<p>内核通过如下的方式调用软中断处理函数：</p>



<pre class="prettyprint"><code class="language-c hljs ">my_softirq-&gt;action(my_softirq);</code></pre>

<p>软中断不会抢占其他软中断，唯一可以抢占软中断的是中断处理程序。</p>



<h4 id="软中断的执行">软中断的执行</h4>

<p>一个注册的软中断必须在被标记后才会被执行，软中断被唤起后，要在 do_softirq() 中执行，在do_softirq()函数中，遍历执行每一个被标记的软中断,如下所示：</p>



<pre class="prettyprint"><code class="language-c hljs ">u32 pending;
<span class="hljs-comment">//pending表示32位的标志，用来标记32个软中断，若位设置为1说明该位对应的软中断唤起。</span>
pending = local_softirq_pending();

<span class="hljs-keyword">if</span>(pending){
    <span class="hljs-keyword">struct</span> softirq_action *h;

    set_softirq_pending(<span class="hljs-number">0</span>);<span class="hljs-comment">//重设置待处理的标志</span>

    h = softirq_vec;
    <span class="hljs-keyword">do</span>{
        <span class="hljs-keyword">if</span>(pending&amp;<span class="hljs-number">1</span>)
            h-&gt;action(h);
        h++;
        pending&gt;&gt;<span class="hljs-number">1</span>;
    }<span class="hljs-keyword">while</span>(pending);
}</code></pre>



<h4 id="软中断的使用">软中断的使用</h4>



<h5 id="1分配索引">1）分配索引</h5>

<p>在编译期间，通过在</p>

<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">enum</span>
{
    HI_SOFTIRQ=<span class="hljs-number">0</span>,       <span class="hljs-comment">//优先级高的tasklet</span>
    TIMER_SOFTIRQ,
    NET_TX_SOFTIRQ,
    NET_RX_SOFTIRQ,
    BLOCK_SOFTIRQ,
    BLOCK_IOPOLL_SOFTIRQ,
    TASKLET_SOFTIRQ,    <span class="hljs-comment">//正常优先级的tasklet</span>
    SCHED_SOFTIRQ,
    HRTIMER_SOFTIRQ,
    RCU_SOFTIRQ,    <span class="hljs-comment">/* Preferable RCU should always be the last softirq */</span>

    NR_SOFTIRQS
};</code></pre>



<h5 id="2注册处理程序">2）注册处理程序</h5>

<p>可以通过open_softirq(）函数注册软中断处理程序，两个参数：软中断索引号、处理函数。</p>



<pre class="prettyprint"><code class="language-c hljs ">open_softirq(NET_RX_SOFTIRQ, net_tx_action);</code></pre>

<p>软中断处理程序执行时候，允许相应中断，但不能自己休眠。 <br>
在一个处理器运行时候，当前处理器上软中断被禁止。</p>



<h5 id="3触发中断">3）触发中断</h5>

<p>raise_softirq()函数可以实现软中断设置为挂起待执行，该函数在运行之前需要先禁止中断，触发后再恢复原来的状态。如果中断本来就已经被禁止，可以采用raise_softirq_irqoff()函数去唤醒中断。</p>



<pre class="prettyprint"><code class="language-c hljs ">raise_softirq(NET_RX_SOFTIRQ)；<span class="hljs-comment">//需要在使用前关中断，然后再恢复。</span>

raise_softirq_irqoff(NET_RX_SOFTIRQ);<span class="hljs-comment">//适用于中断本来就已经被禁止的情况</span>
</code></pre>



<h3 id="2tasklet">2.tasklet</h3>

<pre><code>    tasklet是在软中断基础上实现的，相当于对软中断中的HI_SOFTIRQ、TASKLET_SOFTIRQ的更改，将tasklet链表加入到以上两个软中断的处理函数中执行。
    通常情况下，我们使用tasklet而不是软中断，使用软中断的情况屈指可数。
</code></pre>



<h4 id="tasklet实现">tasklet实现</h4>



<h5 id="tasklet结构">tasklet结构</h5>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> tasklet_struct{
    <span class="hljs-keyword">struct</span> tasklet_struct *next;    <span class="hljs-comment">//链表中下一个tasklet</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> state;            <span class="hljs-comment">//tasklet状态</span>
    atomic_t count;                 <span class="hljs-comment">//原子操作的计数器</span>
    <span class="hljs-keyword">void</span> (*func)(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>);    <span class="hljs-comment">//tasklet处理函数</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> data;             <span class="hljs-comment">//给处理函数的参数</span>
}</code></pre>

<p>结构体重state成员，可以取0、TASKLET_STATE_RUN、TASKLET_STATE_SCHED。 <br>
    TASKLET_STATE_RUN-&gt;正在运行 <br>
    TASKLET_STATE_SCHED-&gt;已被调度</p>



<h5 id="调度">调度</h5>

<p>调度相当于将未调度的tasklet结构添加到两个链表结构：tasklet_vec(普通优先级)、tasklet_hi_vec(高优先级)。</p>



<pre class="prettyprint"><code class="language-cpp hljs ">TASKLET_STATE_SCHED(); <span class="hljs-comment">//tasklet调度函数</span>

<span class="hljs-comment">/*
 * 检查tasklet状态是否为TASKLET_STATE_SCHED，是的话已被调度，直接返回
 * 调用 __TASKLET_STATE_SCHED()函数
 * 保存中断状态，然后禁止中断状态
 * 将被调用的tasklet添加到tasklet链表
 * 唤醒软中断HI_SOFTIRQ或者TASKLET_SOFTIRQ
 * 恢复中断状态并返回</span></code></pre>



<h4 id="使用tasklet">使用tasklet</h4>



<h5 id="1-声明自己的tasklet">1) 声明自己的tasklet</h5>



<pre class="prettyprint"><code class="language-CPP hljs haskell"><span class="hljs-type">DECLEAR_TASKLET</span>(name, func, <span class="hljs-typedef"><span class="hljs-keyword">data</span>)   //声明后tasklet处于激活状态</span>
<span class="hljs-type">DECLEAR_TASKLET_DISABLE</span>(name, func, <span class="hljs-typedef"><span class="hljs-keyword">data</span>)//声明后tasklet处于禁止状态</span></code></pre>



<h5 id="2-编写tasklet处理程序">2） 编写tasklet处理程序</h5>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">void</span> tasklet_handler(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> data)</code></pre>

<p>因为tasklet是靠软中断实现的，因此不能睡眠，也就是说在tasklet处理函数中不能使用信号量或者其他阻塞式函数。</p>



<h5 id="3调度自己的tasklet">3)调度自己的tasklet</h5>

<p>我们可以通过tasklet_schedule()函数并传递给他相应的tasklet指针来调度，如下所示：</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">tasklet_schedule(&amp;mytasklet)</span>; <span class="hljs-comment">//将tasklet指针传过去，来调度</span></code></pre>

<p><strong>要注意：tasklet总在调度他的处理器上执行。</strong></p>



<h3 id="工作队列">工作队列</h3>

<p>工作队列可以把工作推后，交由一个内个线程去执行，这个下半部分总是会在进程上下文中执行。</p>



<h4 id="实现">实现</h4>

<p>工作队列最基本的是表现形式是把需要推后执行的任务交给特定的通用线程（工作队列也可以通过驱动程序创建工作者线程来处理推后工作，但是多数情况直接采用系统缺省的工作者线程来做推后工作）</p>



<h5 id="数据结构">数据结构</h5>

<p>1） 表示线程的数据结构</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">struct</span> workqueue_struct{
    <span class="hljs-keyword">struct</span> ypu_workqueue_struct cpu_wq[NR_CPUS];<span class="hljs-comment">//数组每一项对应一个处理器</span>
    <span class="hljs-keyword">struct</span> list_head list;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;
    <span class="hljs-keyword">int</span> singlethread;
    <span class="hljs-keyword">int</span> freezeable;
    <span class="hljs-keyword">int</span> rt;
}
<span class="hljs-keyword">struct</span> cpu_workqueue_struct{
    spinlock_t <span class="hljs-keyword">lock</span>;<span class="hljs-comment">// 锁来保护这种结构</span>
    <span class="hljs-keyword">struct</span> list_head worklist;<span class="hljs-comment">//工作列表</span>
    wait_queue_head_t more_work;
    <span class="hljs-keyword">struct</span> workqueue_struct * wq;   <span class="hljs-comment">//  关联工作队列结构</span>
    task_t *thread;

}</code></pre>

<p>注意：每一个工作者类型都关联一个自己的workqueue_struct.在该结构体里给每一个处理器（内的工作者线程）分配一个cpu_workqueue_struct。 <br>
2) 表示工作的数据结构</p>

<p>所有的工作者线程都是通过普通的内核线程实现的，他们都执行worker_thread()函数。在他们初始化完成以后，每个函数执行一个死循环并进入休眠，当有操作被传入队列里的时候，线程就会被唤醒，以执行这些操作。</p>

<p>工作用work_struct结构体表示：</p>



<pre class="prettyprint"><code class=" hljs go">  <span class="hljs-keyword">struct</span> work_struct{
        atomic_long_t data; <span class="hljs-comment">//64位原子操作整数</span>
        <span class="hljs-keyword">struct</span> list_head enty;
        work_func_t <span class="hljs-keyword">func</span>;
  }</code></pre>

<p>这些结构体被连成链表，在每个处理器上的每种类型的队列都对应一个这样的链表。</p>



<h4 id="使用工作队列">使用工作队列</h4>



<h5 id="1创建推后的工作">1）创建推后的工作</h5>

<p>首先需要做的是创建一些需要推后完成的实际工作，通过宏DECLEAR_WORK在编译时静态创建结构体，如下所示：</p>



<pre class="prettyprint"><code class=" hljs delphi">DECLEAR_WORK(name; void<span class="hljs-comment">(*func)(void*)</span>,void * data);
<span class="hljs-comment">//这样会静态的创建一个名为name,处理函数为func，参数为data的结构体。</span></code></pre>

<p>也可以在运行时通过指针创建一个工作，如下所示：</p>



<pre class="prettyprint"><code class=" hljs cs">INIT_WORK(<span class="hljs-keyword">struct</span> work_struct *work, <span class="hljs-keyword">void</span>(*func), <span class="hljs-keyword">void</span> *data);
<span class="hljs-comment">//动态初始化一个由work指向的工作</span></code></pre>



<h5 id="2工作队列处理函数">2）工作队列处理函数</h5>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-literal">void</span> work_handler(<span class="hljs-literal">void</span> <span class="hljs-subst">*</span><span class="hljs-built_in">data</span>);<span class="hljs-comment">//工作队列处理函数原型</span></code></pre>

<p>这个函数会有工作者线程执行，因此函数运行于进程上下文中，默认情况下，允许相应中断，不能持有任和锁。 <br>
<strong>需要注意的是，尽管操作函数运行于进程上下文中，但是他不能访问用户空间。</strong></p>



<h4 id="3对工作进行调度">3）对工作进行调度</h4>

<p>可以通过调用函数schedule_work() 把处理函数交给缺省的events工作线程</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">schedule_work(&amp;work)</span>;</code></pre>

<p>work马上就会被调度，一旦其所在的处理器上的工作者线程被唤醒，他就会被执行。 <br>
若不想work马上就工作，二十希望他进行一段延迟再执行，可以通过：</p>



<pre class="prettyprint"><code class=" hljs scss">`<span class="hljs-function">schedule_delay_work(&amp;work, delay)</span>;
<span class="hljs-comment">//此时，直到delay的节拍时钟用完之后才会执行work</span></code></pre>



<h5 id="4刷新操作">4）刷新操作</h5>

<p>进入队列的工作会在工作者线程的下一次被唤醒时候执行，在继续下一步工作之前，需要保证一些操作已经执行完毕。对于模块来说这一点很重要，在卸载之前，他可能需要调用以下函数。而在内核部分，为了防止竞争条件的出现，也可能需要确保不再持有处理工作。</p>

<p>出于以上目的，内核准备了一个用于刷新指定工作队列的函数</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">void</span> flush_schedule_work(<span class="hljs-keyword">void</span>);</code></pre>

<p>函数会一直等待，直到队列中所有对象都被执行以后才会返回。</p>



<h5 id="5创建新的工作队列">5）创建新的工作队列</h5>

<p>如果缺省的队列不能满足你的工作要求，需要创建新的工作队列与相应的工作者进程。由于这么做会在每个处理器上都创建一个工作者线程，所以只有在你明确了必须要自己创建一套线程来提高性能的情况下再创建自己的额工作队列。</p>

<p>这部分用的情况较少，需要的话再细看。</p>



<h2 id="linux内核同步笔记">Linux内核同步笔记</h2>



<h3 id="几个基本概念">几个基本概念</h3>

<pre><code>- 临界区（critical region）：访问和操作共享数据的代码段；
- 原子操作：操作在执行中不被打断，要么不执行，要么执行完；
- 竞争条件： 两个线程处于同一个临界区内执行，对数据同时访问或操作，称之为竞争；
- 同步（synchronization）：避免并发和防止竞争条件成为同步。
</code></pre>



<h3 id="预防死锁">预防死锁</h3>

<pre><code>- 按顺序加锁，使用嵌套锁时，必须注意按顺序加锁，可以防止拥抱类死锁。
- 防止饥饿
- 不要重复请求同一个锁
- 设计力求简单。
</code></pre>



<h3 id="原子操作">原子操作</h3>

<p>原子操作可以保证执行过程不被打断，内核提供了两种原子操作接口：一组针对整数进行操作，另一组针对单独的位进行操作。</p>



<h4 id="原子整数操作">原子整数操作</h4>

<p>针对整数的操作只能对atomic_t类型的数据操作，atomic_t定义如下所示。</p>



<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>{
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> counter;
} atomic_t;</code></pre>

<pre><code>尽管linux支持32整数，但是atomic_t类型只能当做24位来用，这是因为在SPARC体系结构上，原子操作的实现不同于其他系统，在int中的八位引入了一个锁来避免数据并发访问。
</code></pre>



<pre class="prettyprint"><code class=" hljs cs">atomic_t v;                     <span class="hljs-comment">//  定义一个原子整数 v</span>
atomic_t u = ATOMIC_INIT(<span class="hljs-number">0</span>);    <span class="hljs-comment">//定义并初始化u</span>

atomic_set(&amp;v, <span class="hljs-number">4</span>);              <span class="hljs-comment">//设置，赋值</span>
atomic_add(<span class="hljs-number">2</span>, &amp;v);              <span class="hljs-comment">//加</span>
atomic_inc(&amp;v);                 <span class="hljs-comment">//自增</span>

atomic_read(&amp;v);                <span class="hljs-comment">//返回int型数据</span></code></pre>

<p>原子操作通常是内联函数，往往是通过内嵌汇编指令来实现的。在编写代码时，能使用原子操作时，就尽量不要使用复杂的加锁机制。</p>



<h4 id="64位整数的原子操作">64位整数的原子操作</h4>

<p>64位整数操作时，只需要讲atomic_前缀相关的类型及操作函数修改为 atomic64_前缀就可以了。</p>



<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>{
    <span class="hljs-keyword">volatile</span> <span class="hljs-built_in">long</span> counter;
} atomic64_t;

atomic64_t v;                       <span class="hljs-comment">//  定义一个原子整数 v</span>
atomic64_t u = ATOMIC_INIT(<span class="hljs-number">0</span>);  <span class="hljs-comment">//定义并初始化u</span>

atomic64_set(&amp;v, <span class="hljs-number">4</span>);                <span class="hljs-comment">//设置，赋值</span>
atomic64_add(<span class="hljs-number">2</span>, &amp;v);                <span class="hljs-comment">//加</span>
atomic64_inc(&amp;v);                   <span class="hljs-comment">//自增</span>

atomic64_read(&amp;v);              <span class="hljs-comment">//返回int型数据</span></code></pre>



<h4 id="原子位操作">原子位操作</h4>

<p>位操作函数是针对普通地址进行操作的，无需特殊的原子类型，它的参数是一个指针和一个位号。32位系统上位号是0~31，64位系统上位号是0~63。</p>



<pre class="prettyprint"><code class=" hljs cs">usigned <span class="hljs-keyword">long</span> word = <span class="hljs-number">0</span>;

set_bit(<span class="hljs-number">0</span>, &amp;word);      <span class="hljs-comment">//第0位被设置</span>
set_bit(<span class="hljs-number">1</span>, &amp;word);      <span class="hljs-comment">//第1位被设置</span>

printk(<span class="hljs-string">"%ul"</span>, &amp;word);   <span class="hljs-comment">//此处将打印3</span>

clear_bit(<span class="hljs-number">1</span>,&amp;word);     <span class="hljs-comment">//第1位被清除</span>
change_bit(<span class="hljs-number">0</span>, &amp;word);   <span class="hljs-comment">//第0位被翻转</span></code></pre>



<h3 id="自旋锁">自旋锁</h3>

<p>自旋锁最多被一个可执行线程持有，如果一个线程试图获得一个已经被持有的自旋锁（即所谓的争用），那么该线程就会一直进行忙循环——旋转——等待锁重新可用。一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋（自旋特别浪费处理器时间）。</p>

<pre><code>需要注意的是，自旋锁不应被长时间持有，自旋锁适用于短时间内进行轻量级加锁。
</code></pre>



<h4 id="自旋锁方法">自旋锁方法</h4>



<pre class="prettyprint"><code class=" hljs scss">DEFINE_SPIN;<span class="hljs-function">OCK(mr_lock)</span>;
<span class="hljs-function">spin_lock(&amp;mr_lock)</span>;

<span class="hljs-comment">/* 临界区
 * 操作共享数据的代码放于此处
 * 以避免对共享数据的操作并发
 */</span>

<span class="hljs-function">spin_unlock(&amp;mr_lock)</span>;</code></pre>

<pre><code>需要注意，在单处理器机器上，编译的时候并不会加入自旋锁，它仅仅被当做一个设置内核抢占机制是否被启用的开关。如果禁止内核抢占，那么在编译时自旋锁会被完全踢出内核。
</code></pre>

<p>自旋锁可以在中断中使用，在中断中使用自旋锁时，要在使用之前首先禁止本地中断。否则，中断会打断正在持有锁的内核代码，有可能回去争用这个已经被持有的自旋锁，从而造成死锁。内核提供了同时禁止中断和获取锁的函数：</p>



<pre class="prettyprint"><code class=" hljs oxygene">DEFINE_SPIN(mr_lock);
unsigned long <span class="hljs-keyword">flags</span>;

spin_lock_irqsave(&amp;mr_lock, <span class="hljs-keyword">flags</span>);

<span class="hljs-comment">//临界区（critical</span>

spin_unlock_irqrestore(&amp;mr_lock, <span class="hljs-keyword">flags</span>);</code></pre>

<pre><code>要对数据加锁，而不是对代码加锁。加锁保护的是临界区内的数据，而非代码。
</code></pre>

<p>除了上述静态方法添加自旋锁，还可以动态的添加。可以用spin_lock_init()函数动态创建自旋锁。</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">spin_lock()</span>;            <span class="hljs-comment">//  获取指定的自旋锁</span>
<span class="hljs-function">spin_lock_irq()</span>;        <span class="hljs-comment">// 禁止本地中断，并获取自旋锁</span>
<span class="hljs-function">spin_lock_irqsave()</span>;    <span class="hljs-comment">// 获取本地中断状态，禁止本地中断，并获取自旋锁</span>

<span class="hljs-function">spin_unlock()</span>;          <span class="hljs-comment">// 释放指定的锁</span>
<span class="hljs-function">spin_unlock_irq()</span>;      <span class="hljs-comment">// 释放指定的锁，并打开中断</span>
<span class="hljs-function">spin_unlock_irqrestore()</span>;<span class="hljs-comment">// 释放指定锁，并将中断恢复的原有状态</span>

<span class="hljs-function">spin_lock_init()</span>;       <span class="hljs-comment">//  动态初始化指定的spinlock_t</span>
<span class="hljs-function">spin_trylock()</span>;         <span class="hljs-comment">// 试图获取指定的锁，若未获取就返回非0</span>
<span class="hljs-function">spin_is_locked()</span>;       <span class="hljs-comment">// 如果指定的锁正咋被获取，则返回非0，否则返回0</span></code></pre>



<h3 id="读写自旋锁">读写自旋锁</h3>

<p>读取共享数据时，不会对数据造成改变，因此可以多个线程同时对数据进行读取。但是，写数据与读数据是不能同时的。</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">DEFINE_RWLOCK(mr_rwlock)</span>;

<span class="hljs-function">read_lock(&amp;mr_rwlock)</span>;
<span class="hljs-comment">// 临界区(只读)</span>
<span class="hljs-function">read_unlock(&amp;mr_rwlock)</span>;

<span class="hljs-function">write_lock(&amp;mr_lock)</span>;
<span class="hljs-comment">// 临界区(读写)，只能被一个线程获取</span>
<span class="hljs-function">write_unlock(&amp;mr_lock)</span>;
</code></pre>

<p>通常情况下，读锁和写锁处于完全分割的代码分支中。</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">read_lock()</span>;        <span class="hljs-comment">// 获得指定的读锁</span>
<span class="hljs-function">read_lock_irq()</span>;    <span class="hljs-comment">// 禁止本地中断，并获取读锁</span>
<span class="hljs-function">read_lock_irqsave()</span>;<span class="hljs-comment">// 保存本地中断，禁止本地中断，获取读锁</span>

<span class="hljs-function">read_unlock()</span>;      <span class="hljs-comment">// 释放指定读锁</span>
<span class="hljs-function">read_unlock_irq()</span>;  <span class="hljs-comment">// 激活本地中断，并释放读锁</span>
<span class="hljs-function">read_lock_irqstore()</span>;<span class="hljs-comment">// 恢复中断到原有状态，并释放读锁</span>

<span class="hljs-function">write_lock()</span>;       <span class="hljs-comment">// 获得指定的写锁</span>
<span class="hljs-function">write_lock_irq()</span>;   <span class="hljs-comment">// 禁止本地中断，并获取写锁</span>
<span class="hljs-function">write_lock_irqsave()</span>;<span class="hljs-comment">// 保存本地中断，禁止本地中断，获取写锁</span>

<span class="hljs-function">write_unlock()</span>;     <span class="hljs-comment">// 释放指定写锁</span>
<span class="hljs-function">write_unlock_irq()</span>; <span class="hljs-comment">// 激活本地中断，并释放写锁</span>
<span class="hljs-function">write_lock_irqstore()</span>;<span class="hljs-comment">// 恢复中断到原有状态，并释放写锁</span>

<span class="hljs-function">write_trylock()</span>;    <span class="hljs-comment">// 试图获取写锁，写锁不成功则返回非0值</span>
<span class="hljs-function">rwlock_init()</span>;      <span class="hljs-comment">// 初始化指定的rwlock</span></code></pre>

<pre><code>需要注意的是，读写自旋锁照顾读锁更多一点，当读锁被占用时，写操作处于等待状态。但是，读锁却可以继续占用锁，大量的读锁被挂起，会导致写锁处于饥饿状态。
</code></pre>



<h3 id="信号量">信号量</h3>

<p>信号量是一种睡眠锁，如果有一个任务试图获得一个不可用的信号量时，信号量会将其推进一个等待队列。</p>

<pre><code>- 由于争优信号量的进程在等待时会睡眠，所以信号量适用于锁会被长时间锁定的情况。
- 锁被短时间持有的情况不适合使用信号量，因为睡眠、维护等待队列以及唤醒所花费的时间可能比锁占用的时间还要长
- 由于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下文中是不可睡眠的。
- 可以在持有锁时去睡眠，其他进程试图获取该锁时，并不会死锁，而是去睡眠了。
- 占用信号量时不可以同时占用自旋锁，因为在等待信号量时有可能睡眠，而持有自旋锁时是不允许睡眠的。
</code></pre>



<h4 id="计数信号量和二值信号量">计数信号量和二值信号量</h4>

<p>信号量可以同时允许任意数量的锁持有者，而自旋锁在一个时刻最多允许一个任务持有它，通过一个计数count来表示。只允许一个持有者的信号量称为二值信号量（也成为互斥信号量），其count为1。</p>

<p>Linux通过down()操作来请求获得一个信号量，down()对信号量计数减1，若结果大于等于0则持有该信号量，若小于0则线程被放入等待队列。临界区内操作完成之后，通过up()来释放信号量，信号量计数加1。</p>



<h4 id="创建和初始化信号量">创建和初始化信号量</h4>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">struct</span> semaphore name;      <span class="hljs-comment">// 定义信号量</span>
sema_init(&amp;name, count);    <span class="hljs-comment">// 初始化， count表示信号量的使用数量</span>
</code></pre>

<p>创建互斥信号量可以用以下更简洁的方式</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-value">static</span> <span class="hljs-function">DECLEAR_MUTEX(name)</span>;</code></pre>

<p>更常见的情况是，信号量作为一个大数据结构动态创建。此时，只有指向该动态创建的信号量的简介指针，可以使用如下函数来对他进行初始化：</p>



<pre class="prettyprint"><code class=" hljs axapta">sama_init(sem, <span class="hljs-keyword">count</span>);</code></pre>

<p>动态初始化可以通过如下函数：</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">init_MUTEX(sem)</span>;</code></pre>



<h4 id="使用信号量">使用信号量</h4>

<p>通过函数<strong>down_interruptible()</strong>获取指定信号量，如果信号量不可用，就将调用进程设置成TASK_INTERRUPTIBLE状态进入睡眠。</p>

<p>使用down_trylock()函数可以尝试以堵塞的方式来获取指定的信号量。在信号已经被占领时，它返回非0值；否则返回0，并让你成功持有信号量锁。</p>



<pre class="prettyprint"><code class=" hljs r">static DECLEAR_MUTEX(mr_sem);   //定义并声明一个信号量锁

<span class="hljs-keyword">if</span>(down_interruptible(&amp;mr_sem)){

    //信号量未获取
}

/*  临界区<span class="hljs-keyword">...</span> */

up(&amp;mr_sem);    //释放给定的信号量
</code></pre>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//信号量主要方法</span>

sema_init(<span class="hljs-keyword">struct</span> semaphore *, <span class="hljs-keyword">int</span>);     <span class="hljs-comment">// 以指定的计数值初始化动态创建信号量</span>
init_MUTEX(<span class="hljs-keyword">struct</span> semaphore *);         <span class="hljs-comment">// 以计数值1初始化动态创建信号量</span>
down_interruptible(<span class="hljs-keyword">struct</span> semaphore *)  <span class="hljs-comment">// 试图获取指定信号量，若信号被占用，则进入中断休眠状态</span>
down(<span class="hljs-keyword">struct</span> semaphore*)                 <span class="hljs-comment">// 试图获取指定信号量，若信号被占用，则进入不可中断睡眠状态</span>
down_trylock(<span class="hljs-keyword">struct</span> semaphore*)         <span class="hljs-comment">// 试图获取指定信号量，若信号被争用，则立刻返回非0值</span>
up(<span class="hljs-keyword">struct</span> semaphore*)                   <span class="hljs-comment">// 释放信号量，如果睡眠队列不空，则唤醒其中一个任务 </span></code></pre>



<h3 id="读写信号量">读写信号量</h3>

<p>与读写自旋锁类似，将信号量更具体为读写信号量。所有的读写信号量都是互斥信号量，他们只针对写操作互斥，不针对读者。也就是说，只要没有写锁定，并发的读锁数量不限。只要有写锁，就不可以有其他读锁或者写锁。</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-comment">// 静态创建</span>
<span class="hljs-value">static</span> <span class="hljs-function">DECLEAR_RWSEM(name)</span>

<span class="hljs-comment">// 动态创建</span>
<span class="hljs-function">init_rwsem(struct rw_semaphore * sem)</span>

<span class="hljs-comment">// 使用例子</span>
<span class="hljs-value">static</span> <span class="hljs-function">DECLEAR_RWSEM(mr_rwsem)</span>；

<span class="hljs-function">down_read(&amp;mr_rwsem)</span>;   <span class="hljs-comment">//获取读信号量锁</span>

<span class="hljs-comment">// 临界区（只读）</span>

<span class="hljs-function">up_read(&amp;mr_rwsem)</span>;     <span class="hljs-comment">//释放读信号量锁</span>

<span class="hljs-function">down_write(&amp;mr_rwsem)</span>;  <span class="hljs-comment">// 获取写信号量锁</span>

<span class="hljs-comment">// 临界区（写）</span>

<span class="hljs-function">up_write(&amp;mr_rwsem)</span>;    <span class="hljs-comment">// 释放写信号量锁</span>
</code></pre>



<h3 id="互斥体mutex">互斥体（mutex）</h3>

<p>一种互斥的睡眠锁，其操作与计数为1的信号量相似，其接口更简单。</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">DEFINE_MUTEX(name)</span>;     <span class="hljs-comment">// 静态初始化</span>

<span class="hljs-function">mutex_init(&amp;mutex)</span>;     <span class="hljs-comment">// 动态初始化</span>

<span class="hljs-function">mutex_lock(&amp;mutex)</span>;     <span class="hljs-comment">// 获取锁</span>
    <span class="hljs-comment">/* 临界区  */</span>
<span class="hljs-function">mutex_unlock(&amp;mutex)</span>;   <span class="hljs-comment">// 释放锁</span>
</code></pre>

<pre><code>- 任何时刻只有一个任务可以持有mutex
- 给mutex上锁者必须负责给其解锁
- 在同一个上下文中上锁和解锁
- 当持有一个mutex时，进程不可以退出。
- mutex不能在中断或者下半部中使用，即使是mutex_trylock()也不行
- mutex只能通过官方API管理

信号量和互斥体二者很相似，在使用时要优先使用mutex，只有在很特殊的场合才会使用信号量（一般在底层）。
</code></pre>



<h3 id="完成变量completion-variable">完成变量（completion variable）</h3>

<p>如果在内核中一个任务需要发出信号通知另一个任务发生了某个特定事件，可以利用完成变量使两个任务得以同步。</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">DECLEAR_COMPLETION(mr_comp)</span>;    <span class="hljs-comment">// 静态初始化</span>
<span class="hljs-function">init_completion(&amp;mr_comp)</span>;      <span class="hljs-comment">//动态创建</span>

<span class="hljs-function">wait_for_completion(&amp;mr_comp)</span>;  <span class="hljs-comment">//等待某完成变量接受信号</span>
<span class="hljs-function">complete(&amp;mr_comp)</span>;             <span class="hljs-comment">//发信号唤醒任何等待的任务</span>
</code></pre>



<h3 id="顺序锁">顺序锁</h3>

<p>顺序锁的实现是通过一个序列计数器实现的，当有疑义的数据被写入之后，会得到一个锁，并且计数值增加。在读取数据前后，序列号都会被读取。如果读取的序列号值相同，说明在读操作过程中没有被写操作打断过。此外，如果序列数是偶数说明没有写操作发生，因为写锁会使值变成基数，读操作后值恢复到偶数。</p>



<pre class="prettyprint"><code class=" hljs objectivec">seqlock_t mr_seq_lock = DEFINE_SEQLOCK(mr_seq_lock);

write_seqlock(&amp;mr_seq_lock);
<span class="hljs-comment">//写锁被读取</span>
write_sequnlock(&amp;mr_seq_lock);

<span class="hljs-comment">// 写锁与自旋锁类似，差异在于读的时候</span>
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> seq;

<span class="hljs-keyword">do</span>{
    seq = read_seqbegin(&amp;mr_seq_lock);
    <span class="hljs-comment">//开始读数据。。</span>
}<span class="hljs-keyword">while</span>(read_seqretry(&amp;mr_seq_lock, seq));
</code></pre>



<h3 id="禁止抢占">禁止抢占</h3>

<p>由于内核是抢占性的，内核的进程在任何时候都可以停下来执行更改优先权的进程，这意味着一个任务与被强占的任务可能在同一个临界区内运行。为了避免这种情况，内核抢占代码使用自旋锁作为非抢占区域的标志。如果一个自旋锁被持有，则内核不能进行抢占。</p>

<p>可以通过preempt_disable()来禁止内核抢占。</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">preempt_disable()</span>;
<span class="hljs-comment">//内核禁止被抢占</span>
<span class="hljs-function">preempt_enable()</span>;
</code></pre>



<h3 id="顺序和屏障">顺序和屏障</h3>



<h2 id="crt0smain代码分析">crt0,S(_main)代码分析</h2>

<hr>



<h3 id="1-设置sp寄存器地址">1. 设置sp寄存器地址</h3>



<pre class="prettyprint"><code class="language-C hljs cs"><span class="hljs-comment">//设置SP栈指针</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)</span>
    ldr sp, =(CONFIG_SPL_STACK)
<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span></span>
    ldr sp, =(CONFIG_SYS_INIT_SP_ADDR)
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-comment">//设置地址八位对齐</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> defined(CONFIG_CPU_V7M) /* v7M forbids using SP as BIC destination*/</span>
    mov r3, sp             
    bic r3, r3, <span class="hljs-preprocessor">#7         //* 后三位清零相当于堆栈地址八位对齐</span>
    mov sp, r3               
<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span></span>
    bic sp, sp, <span class="hljs-preprocessor">#7  /* 8-byte alignment for ABI compliance */   </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span></code></pre>



<h3 id="2-在栈中为全局变量gd分配空间">2. 在栈中为全局变量gd分配空间</h3>



<pre class="prettyprint"><code class=" hljs avrasm">// <span class="hljs-built_in">r0</span>寄存器传递函数的参数
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, sp
bl  board_init_f_alloc_reserve  //在栈中为全局数据分配空间
<span class="hljs-keyword">mov</span> sp, <span class="hljs-built_in">r0</span>      
//函数调用后返回值在<span class="hljs-built_in">r0</span>中，将其保存到sp寄存器中  
//根据下面的board_init_f_alloc_reserve函数
//函数返回值为分配gb后的指针位置</code></pre>

<p>board_init_f_alloc_reserve函数原型如下：</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">ulong</span> board_init_f_alloc_reserve(<span class="hljs-keyword">ulong</span> top)
{
    <span class="hljs-comment">//将栈顶指针传进来，栈顶指针减去全局变量的长度意味着数据入栈，即在栈里预留变量存储空间。</span>
    <span class="hljs-comment">/* Reserve early malloc arena */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> defined(CONFIG_SYS_MALLOC_F)</span>
    top -= CONFIG_SYS_MALLOC_F_LEN;
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
    <span class="hljs-comment">/* LAST : reserve GD (rounded up to a multiple of 16 bytes) */</span>
    top = rounddown(top-<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> global_data), <span class="hljs-number">16</span>);
    <span class="hljs-keyword">return</span> top;
}</code></pre>



<h3 id="3-在栈中gd空间清零">3. 在栈中gd空间清零</h3>



<pre class="prettyprint"><code class=" hljs avrasm">    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">r9</span>, <span class="hljs-built_in">r0</span>  //将栈顶指针存到<span class="hljs-built_in">r9</span>寄存器里面,方便后续设置gd指针
    bl  board_init_f_init_reserve   //全局数据全部清零</code></pre>

<p>board_init_f_init_reserve   函数定义如下：</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">void</span> board_init_f_init_reserve(<span class="hljs-keyword">ulong</span> <span class="hljs-keyword">base</span>)
{
    <span class="hljs-keyword">struct</span> global_data *gd_ptr;
<span class="hljs-preprocessor">#ifndef _USE_MEMCPY</span>
    <span class="hljs-keyword">int</span> *ptr;
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>

    <span class="hljs-comment">/*
     * clear GD entirely and set it up.
     * Use gd_ptr, as gd may not be properly set yet.
     * 清除GD分配空间
     */</span>

    gd_ptr = (<span class="hljs-keyword">struct</span> global_data *)<span class="hljs-keyword">base</span>;
    <span class="hljs-comment">/* zero the area */</span>
<span class="hljs-preprocessor">#ifdef _USE_MEMCPY</span>
    memset(gd_ptr, <span class="hljs-string">'\0'</span>, <span class="hljs-keyword">sizeof</span>(*gd));  <span class="hljs-comment">//全局数据区全部清零</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span></span>
    <span class="hljs-keyword">for</span> (ptr = (<span class="hljs-keyword">int</span> *)gd_ptr; ptr &lt; (<span class="hljs-keyword">int</span> *)(gd_ptr + <span class="hljs-number">1</span>); )
        *ptr++ = <span class="hljs-number">0</span>;
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>

    <span class="hljs-comment">/* set GD unless architecture did it already */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> !defined(CONFIG_ARM)</span>
    arch_setup_gd(gd_ptr);
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
    <span class="hljs-comment">/* next alloc will be higher by one GD plus 16-byte alignment */</span>
    <span class="hljs-keyword">base</span> += roundup(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> global_data), <span class="hljs-number">16</span>);

    <span class="hljs-comment">/*
     * record early malloc arena start.
     * Use gd as it is now properly set for all architectures.
     */</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> defined(CONFIG_SYS_MALLOC_F)</span>
    <span class="hljs-comment">/* go down one 'early malloc arena' */</span>
    gd-&gt;malloc_base = <span class="hljs-keyword">base</span>;
    <span class="hljs-comment">/* next alloc will be higher by one 'early malloc arena' size */</span>
    <span class="hljs-keyword">base</span> += CONFIG_SYS_MALLOC_F_LEN;
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
}</code></pre>



<h3 id="4-调用boardinitf初始化各种硬件">4. 调用board_init_f，初始化各种硬件</h3>



<pre class="prettyprint"><code class=" hljs avrasm">    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-preprocessor">#0</span>
    bl  board_init_f    // jump to ==&gt; board_f<span class="hljs-preprocessor">.c</span></code></pre>

<p>在board_init_f函数中所进行的主要操作如下，其中init_sequence_f[ ]是一个数组，其内容为一系列初始化函数，在函数initcall_run_list中依次调用init_sequence_f数组的各个初始化函数。</p>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-literal">void</span> board_init_f(ulong boot_flags)
{
    <span class="hljs-comment">//此处省略多行代码</span>
    gd<span class="hljs-subst">-&gt;</span>flags <span class="hljs-subst">=</span> boot_flags;
    gd<span class="hljs-subst">-&gt;</span>have_console <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">//通过调用initcall_run_list函数，执行各项初始化   </span>
    <span class="hljs-keyword">if</span> (initcall_run_list(init_sequence_f)) 
        hang();
}</code></pre>

<p>initcall_run_list函数如下：</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">int</span> initcall_run_list(<span class="hljs-keyword">const</span> init_fnc_t init_sequence[])
{   
    <span class="hljs-keyword">const</span> init_fnc_t *init_fnc_ptr;
    <span class="hljs-keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
        <span class="hljs-keyword">int</span> ret;
        <span class="hljs-comment">//此处省略很多代码</span>
        <span class="hljs-comment">//通过函数指针依次调用数组内函数</span>
        ret = (*init_fnc_ptr)();        
    }
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>数组init_sequence_f[ ]定义如下，每个成员为一个函数指针，函数参数为void，返回类型为int</p>



<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-keyword">static</span> init_fnc_t init_sequence_f[] = {
<span class="hljs-preprocessor">#ifdef CONFIG_SANDBOX</span>
    setup_ram_buf,
<span class="hljs-preprocessor">#endif</span>
    setup_mon_len,
<span class="hljs-preprocessor">#ifdef CONFIG_OF_CONTROL</span>
    fdtdec_setup,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#ifdef CONFIG_TRACE</span>
    trace_early_init,
<span class="hljs-preprocessor">#endif</span>
    initf_malloc,
    initf_console_record,
<span class="hljs-preprocessor">#if defined(CONFIG_MPC85xx) || defined(CONFIG_MPC86xx)</span>
    <span class="hljs-comment">/* TODO: can this go into arch_cpu_init()? */</span>
    probecpu,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_X86) &amp;&amp; defined(CONFIG_HAVE_FSP)</span>
    x86_fsp_init,
<span class="hljs-preprocessor">#endif</span>
    arch_cpu_init,      <span class="hljs-comment">/* basic arch cpu dependent setup */</span>
    mach_cpu_init,      <span class="hljs-comment">/* SoC/machine dependent CPU setup */</span>
    initf_dm,
    arch_cpu_init_dm,
    mark_bootstage,     <span class="hljs-comment">/* need timer, go after init dm */</span>
<span class="hljs-preprocessor">#if defined(CONFIG_BOARD_EARLY_INIT_F)</span>
    board_early_init_f,
<span class="hljs-preprocessor">#endif</span>
    <span class="hljs-comment">/* TODO: can any of this go into arch_cpu_init()? */</span>
<span class="hljs-preprocessor">#if defined(CONFIG_PPC) &amp;&amp; !defined(CONFIG_8xx_CPUCLK_DEFAULT)</span>
    get_clocks,     <span class="hljs-comment">/* get CPU and bus clocks (etc.) */</span>
<span class="hljs-preprocessor">#if defined(CONFIG_TQM8xxL) &amp;&amp; !defined(CONFIG_TQM866M) \</span>
        &amp;&amp; !defined(CONFIG_TQM885D)
    adjust_sdram_tbs_8xx,
<span class="hljs-preprocessor">#endif</span>
    <span class="hljs-comment">/* TODO: can we rename this to timer_init()? */</span>
    init_timebase,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_ARM) || defined(CONFIG_MIPS) || \</span>
        defined(CONFIG_BLACKFIN) || defined(CONFIG_NDS32) || \
        defined(CONFIG_SH) || defined(CONFIG_SPARC)
    timer_init,     <span class="hljs-comment">/* initialize timer */</span>
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#ifdef CONFIG_SYS_ALLOC_DPRAM</span>
<span class="hljs-preprocessor">#if !defined(CONFIG_CPM2)</span>
    dpram_init,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_BOARD_POSTCLK_INIT)</span>
    board_postclk_init,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_SYS_FSL_CLK) || defined(CONFIG_M68K)</span>
    get_clocks,
<span class="hljs-preprocessor">#endif</span>
    env_init,       <span class="hljs-comment">/* initialize environment */</span>
<span class="hljs-preprocessor">#if defined(CONFIG_8xx_CPUCLK_DEFAULT)</span>
    <span class="hljs-comment">/* get CPU and bus clocks according to the environment variable */</span>
    get_clocks_866,
    <span class="hljs-comment">/* adjust sdram refresh rate according to the new clock */</span>
    sdram_adjust_866,
    init_timebase,
<span class="hljs-preprocessor">#endif</span>
    init_baud_rate,     <span class="hljs-comment">/* initialze baudrate settings */</span>
    serial_init,        <span class="hljs-comment">/* serial communications setup */</span>
    console_init_f,     <span class="hljs-comment">/* stage 1 init of console */</span>
<span class="hljs-preprocessor">#ifdef CONFIG_SANDBOX</span>
    sandbox_early_getopt_check,
<span class="hljs-preprocessor">#endif</span>
    display_options,    <span class="hljs-comment">/* say that we are here */</span>
    display_text_info,  <span class="hljs-comment">/* show debugging info if required */</span>
<span class="hljs-preprocessor">#if defined(CONFIG_MPC8260)</span>
    prt_8260_rsr,
    prt_8260_clks,
<span class="hljs-preprocessor">#endif /* CONFIG_MPC8260 */</span>
<span class="hljs-preprocessor">#if defined(CONFIG_MPC83xx)</span>
    prt_83xx_rsr,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_SH)</span>
    checkcpu,
<span class="hljs-preprocessor">#endif</span>
    print_cpuinfo,      <span class="hljs-comment">/* display cpu info (and speed) */</span>
<span class="hljs-preprocessor">#if defined(CONFIG_MPC5xxx)</span>
    prt_mpc5xxx_clks,
<span class="hljs-preprocessor">#endif /* CONFIG_MPC5xxx */</span>
<span class="hljs-preprocessor">#if defined(CONFIG_DTB_RESELECT)</span>
    embedded_dtb_select,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_DISPLAY_BOARDINFO)</span>
    show_board_info,
<span class="hljs-preprocessor">#endif</span>
    INIT_FUNC_WATCHDOG_INIT
<span class="hljs-preprocessor">#if defined(CONFIG_MISC_INIT_F)</span>
    misc_init_f,
<span class="hljs-preprocessor">#endif</span>
    INIT_FUNC_WATCHDOG_RESET
<span class="hljs-preprocessor">#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)</span>
    init_func_i2c,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_HARD_SPI)</span>
    init_func_spi,
<span class="hljs-preprocessor">#endif</span>
    announce_dram_init,
    <span class="hljs-comment">/* TODO: unify all these dram functions? */</span>
<span class="hljs-preprocessor">#if defined(CONFIG_ARM) || defined(CONFIG_X86) || defined(CONFIG_NDS32) || \</span>
        defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32) || \
        defined(CONFIG_SH)
    dram_init,      <span class="hljs-comment">/* configure available RAM banks */</span>
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(CONFIG_M68K)</span>
    init_func_ram,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#ifdef CONFIG_POST</span>
    post_init_f,
<span class="hljs-preprocessor">#endif</span>
    INIT_FUNC_WATCHDOG_RESET
<span class="hljs-preprocessor">#if defined(CONFIG_SYS_DRAM_TEST)</span>
    testdram,
<span class="hljs-preprocessor">#endif /* CONFIG_SYS_DRAM_TEST */</span>
    INIT_FUNC_WATCHDOG_RESET

<span class="hljs-preprocessor">#ifdef CONFIG_POST</span>
    init_post,
<span class="hljs-preprocessor">#endif</span>
    INIT_FUNC_WATCHDOG_RESET
    <span class="hljs-comment">/*
     * Now that we have DRAM mapped and working, we can
     * relocate the code and continue running from DRAM.
     *
     * Reserve memory at end of RAM for (top down in that order):
     *  - area that won't get touched by U-Boot and Linux (optional)
     *  - kernel log buffer
     *  - protected RAM
     *  - LCD framebuffer
     *  - monitor code
     *  - board info struct
     */</span>
    setup_dest_addr,
<span class="hljs-preprocessor">#if defined(CONFIG_BLACKFIN) || defined(CONFIG_XTENSA)</span>
    <span class="hljs-comment">/* Blackfin u-boot monitor should be on top of the ram */</span>
    reserve_uboot,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_SPARC)</span>
    reserve_prom,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_LOGBUFFER) &amp;&amp; !defined(CONFIG_ALT_LB_ADDR)</span>
    reserve_logbuffer,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#ifdef CONFIG_PRAM</span>
    reserve_pram,
<span class="hljs-preprocessor">#endif</span>
    reserve_round_4k,
<span class="hljs-preprocessor">#if !(defined(CONFIG_SYS_ICACHE_OFF) &amp;&amp; defined(CONFIG_SYS_DCACHE_OFF)) &amp;&amp; \</span>
        defined(CONFIG_ARM)
    reserve_mmu,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#ifdef CONFIG_DM_VIDEO</span>
    reserve_video,
<span class="hljs-preprocessor">#else</span>
<span class="hljs-preprocessor"># ifdef CONFIG_LCD</span>
    reserve_lcd,
<span class="hljs-preprocessor"># endif</span>
    <span class="hljs-comment">/* TODO: Why the dependency on CONFIG_8xx? */</span>
<span class="hljs-preprocessor"># if defined(CONFIG_VIDEO) &amp;&amp; (!defined(CONFIG_PPC) || defined(CONFIG_8xx)) &amp;&amp; \</span>
        !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_X86) &amp;&amp; \
        !defined(CONFIG_BLACKFIN) &amp;&amp; !defined(CONFIG_M68K)
    reserve_legacy_video,
<span class="hljs-preprocessor"># endif</span>
<span class="hljs-preprocessor">#endif /* CONFIG_DM_VIDEO */</span>
    reserve_trace,
<span class="hljs-preprocessor">#if !defined(CONFIG_BLACKFIN) &amp;&amp; !defined(CONFIG_XTENSA)</span>
    reserve_uboot,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#ifndef CONFIG_SPL_BUILD</span>
    reserve_malloc,
    reserve_board,
<span class="hljs-preprocessor">#endif</span>
    setup_machine,
    reserve_global_data,
    reserve_fdt,
    reserve_arch,
    reserve_stacks,
    setup_dram_config,
    show_dram_config,
<span class="hljs-preprocessor">#if defined(CONFIG_M68K) || defined(CONFIG_MIPS) || defined(CONFIG_PPC) || \</span>
    defined(CONFIG_SH)
    setup_board_part1,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_PPC) || defined(CONFIG_M68K)</span>
    INIT_FUNC_WATCHDOG_RESET
    setup_board_part2,
<span class="hljs-preprocessor">#endif</span>
    display_new_sp,
<span class="hljs-preprocessor">#ifdef CONFIG_SYS_EXTBDINFO</span>
    setup_board_extra,
<span class="hljs-preprocessor">#endif</span>
    INIT_FUNC_WATCHDOG_RESET
    reloc_fdt,
    setup_reloc,
<span class="hljs-preprocessor">#if defined(CONFIG_X86) || defined(CONFIG_ARC)</span>
    copy_uboot_to_ram,
    clear_bss,
    do_elf_reloc_fixups,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if defined(CONFIG_XTENSA)</span>
    clear_bss,
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#if !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_SANDBOX)</span>
    jump_to_copy,
<span class="hljs-preprocessor">#endif</span>
    NULL,
};</code></pre></div></body>
</html>
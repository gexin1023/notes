<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>notes_2017_8_4</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h1 id="第1月第3周笔记">第1月第3周笔记</h1>



<h2 id="定时器与时间管理笔记">定时器与时间管理笔记</h2>



<h3 id="内核中的时间">内核中的时间</h3>

<ul>
<li>时钟中断：内核中的系统定时器以某种频率触发中断，该频率可以通过编程预定。</li>
<li>节拍率HZ：时钟中断的频率称为节拍率。</li>
<li>节拍：相邻两次中断的时间间隔称为节拍，1/节拍率。</li>
</ul>



<h3 id="节拍率hz">节拍率HZ</h3>

<p>系统定时器的节拍率是通过静态预处理定义的，也就是HZ值，在系统启动时按照HZ值对硬件进行设置。比如，x86系统的HZ默认值为100，即每10ms触发一次时钟中断。</p>



<h3 id="jiffies">jiffies</h3>

<p>该全局变量用来记录自系统启动以来产生的节拍数总数。在启动时，内核将该值初始化为0，每次时钟中断该值都会增加1。</p>



<pre class="prettyprint"><code class=" hljs livecodeserver">    <span class="hljs-built_in">time</span> = jiffies /HZ;    <span class="hljs-comment"> //自启动以来经历的时间</span>
</code></pre>

<p>jiffies在系统中的定义如下，它是无符号长整数，因此在32位系统是32位，在64位系统上是64位。 </p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> jiffies;
<span class="hljs-keyword">extern</span>  u64 jiffies_64;
</code></pre>

<p>系统还定义了一个变量jiffies_64，该变量在32位系统也是64位长，这样可以保证该变量不会溢出。在32位系统上，通过赋值将jiffies_64的低32位给jiffies，因为我们使用jiffies主要是来计算经过的相对时间，因此低32位足够使用了。在64位机上两个变量值是相同的。</p>

<p>当jiffies值超过他的最大存放范围之后，就会发生溢出。对于32位系统而言，当jiffies超过 <script type="math/tex" id="MathJax-Element-1">2^32-1</script> 后，会再次回到0，这个过程称之为回绕。</p>

<p>我们在代码时需要注意jiffies是否会发生回绕，比如下面这个例子，当我们判断是否超时时，就需要考虑到回绕的情况。在下面的例子中，加入发生回绕，即使超时了，<script type="math/tex" id="MathJax-Element-2">timeout > jiffies</script> 也是成立的。</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> timeout = jiffies + HZ/<span class="hljs-number">2</span>;<span class="hljs-comment">//0.5秒之后的时刻</span>

<span class="hljs-keyword">if</span>(timeout &gt; jiffies)
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"未超时"</span>)；
<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"已超时"</span>)；</code></pre>

<p>为了解决这种情况，内核提供了四个宏来比较节拍数，这是通过将 unsigned long 类型强制转换为 long 类型实现的。通过强制类型装换，即使发生回绕，也是从负数回绕到了正数，其大小关系不变。</p>



<pre class="prettyprint"><code class=" hljs java">#define time_after(unkown,kwon)     ((<span class="hljs-keyword">long</span>)(kown)-(<span class="hljs-keyword">long</span>)(unkown))&lt;<span class="hljs-number">0</span>
#define time_before(unkown,kown)    ((<span class="hljs-keyword">long</span>)(unkown) -(<span class="hljs-keyword">long</span>)(kown))&lt;<span class="hljs-number">0</span>
#deifne time_after_eq(unkown,kwon)      ((<span class="hljs-keyword">long</span>)(unkown) -(<span class="hljs-keyword">long</span>)(kown))&gt;=<span class="hljs-number">0</span>
#define time_before_eq(unkown,kown)  ((<span class="hljs-keyword">long</span>)(kown)-(<span class="hljs-keyword">long</span>)(unkown))&gt;=<span class="hljs-number">0</span></code></pre>



<h3 id="硬时钟和定时器">硬时钟和定时器</h3>

<p>系统中存在两种设备进行计时，分别是系统定时器和实时时钟。</p>



<h4 id="实时时钟">实时时钟</h4>

<p>实时时钟（RTC）是用来持久存放系统时间的设备，即使系统关闭后，它依然可以靠着主板上的微型电池供电保持系统计时。</p>

<p>当系统启动时，内核通过读取RTC来初始化墙上时间，改时间存放在xtime变量中。内核通常不会在系统启动后再读取xtime变量，有些体系结构会周期性的将当前时间存回RTC中。实时时钟的主要作用就是在启动时初始化xtime。</p>



<h4 id="系统定时器">系统定时器</h4>

<p>系统定时器提供一种周期性的触发中断机制，</p>



<h3 id="时钟中断处理程序">时钟中断处理程序</h3>

<p>时钟中断处理程序分为两个部分：体系结构相关部分和体系结构无关部分。</p>

<p>与体系相关的例程作为系统定时器的中断被注册到内核中，以便在产生时钟中断时能够相应运行。该部分一般包括以下内容： <br>
    - 获得xtime_lock锁，一遍对jiffies_64和墙上时间xtime进行保护 <br>
    - 需要时应答或重新设置系统时钟 <br>
    - 周期性使用墙上时间更新实时时钟 <br>
    - 调用体系结构无关例程tick_periodic()</p>

<p>中断服务主要通过体系结构无关部分执行更多工作，tick_periodic()： <br>
    - 给jiffies_64增加1 <br>
    - 更新资源的统计值 <br>
    - 执行一定到期的动态定时器 <br>
    - 更新墙上时间 <br>
    - 计算平均负载</p>



<h3 id="定时器">定时器</h3>

<p>定时器也称为动态定时器或内核定时器，是管理内核时间流逝的基础。</p>

<p>定时器结构如下：</p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">struct</span> timer_list{
    <span class="hljs-keyword">struct</span> list_head entry; <span class="hljs-comment">//定时器链表入口</span>
    <span class="hljs-keyword">unsigned</span> ling expires;  <span class="hljs-comment">// 以jiffies为单位的定时值</span>
    <span class="hljs-keyword">void</span> (*function) (<span class="hljs-keyword">unsigned</span> ling);<span class="hljs-comment">//定时器处理函数</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> data;         <span class="hljs-comment">// 传给处理函数的长整型</span>
    <span class="hljs-keyword">struct</span> tvec_t_base_s *base; <span class="hljs-comment">//定时器内部值，用户不需要</span>
}</code></pre>

<p>创建定时器时，首先要定义</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">struct</span> timer_list  my_timer;</code></pre>

<p>接着初始化定时器结构</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">init_timer(&amp;my_timer)</span>;</code></pre>

<p>然后给定时器结构中的成员赋值</p>



<pre class="prettyprint"><code class=" hljs avrasm">my_timer<span class="hljs-preprocessor">.expires</span> = jiffies + delay<span class="hljs-comment">;</span>
my_timer<span class="hljs-preprocessor">.data</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
my_timer<span class="hljs-preprocessor">.function</span> = my_function<span class="hljs-comment">;</span></code></pre>

<p>定时器处理函数的定义如下</p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">void</span> my_function(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> data);</code></pre>

<p>最后，还需要激活定时器</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">add_timer(&amp;my_timer)</span>;</code></pre>

<p>当节拍数大于等于指定的额超时时，内核就开始执行定时器处理函数。虽然内核可以保证在超时时间到达之前不会执行处理函数，但是会有延误。一般来说，定时器在超时后会马上执行，但也有可能推迟到下次节拍再运行。</p>

<p>有时候需要更改已经激活的定时器时间，可以通过内核函数mod_timer来实现</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">mod_timer(&amp;my_timer, jiffies + new_delay)</span>;</code></pre>

<p>mod_timer()函数也可以操作那些已经初始化，但还没有激活的定时器。若还没有激活，mod_timer()就会激活该函数。一旦从mod_timer()函数返回，定时器将被激活，并设置新的定时时间。</p>

<p>若需要在定时器超时之前停止计时器可通过del_timer()来实现</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">del_timer(&amp;my_timer)</span>;</code></pre>

<p>被激活的或未被激活的定时器都可以使用该函数，若未被激活则返回0；否则返回1.</p>

<p>当删除定时器时，必须注意一个潜在的竞争条件，当del_timer()返回后，可以保证的只是，定时器将来不会再被激活，但是在多处理器机器上定时器中断可能已经在其他处理器上运行了。所以删除定时器时需要等待可能在其他处理器上运行的定时器处理程序都结束，这时就要用del_timer_sync()</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">del_timer_sync(&amp;my_timer)</span>;</code></pre>



<h3 id="延迟执行">延迟执行</h3>

<p>内核代码（尤其是驱动程序代码）除了使用定时器或下半部意外还需要其他方法来退出任务。这种推迟常发生在等待硬件完成某项工作时，而且等待时间很短。</p>



<h4 id="忙等待">忙等待</h4>

<p>最简单的延迟方法是忙等待，实现方法如下：</p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> timeout = jiffies + <span class="hljs-number">10</span>;

<span class="hljs-keyword">while</span>(time_before(jiffies,before);  <span class="hljs-comment">// 忙等待10个节拍的时间</span>
</code></pre>

<p>这种方法十分低效，尽量别用，丢人。。。</p>

<p>更好的方法是在等待的时候，运行内核重新调度执行其他任务：</p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> timeout = jiffies + <span class="hljs-number">2</span>*HZ;

<span class="hljs-keyword">while</span>(time_before(jiffies,before)
    <span class="hljs-comment">// 忙等待2秒的时间</span>
    cond_resched();
</code></pre>

<p>cond_resched()函数将调度一个新的程序投入运行，但它只有在设置完need_resched标志后才能生效。也就是说，该方法有效的条件是系统中存在更重要的任务需要运行。注意，该方法需要调用调度程序，所以他不能再中断上下文中使用。事实上，所有的延迟方法在进程上下文中使用很好，而中断处理程序需要更快的执行（忙循环与这种目标相反）。延迟执行不管在那种情况下都不应该在持有锁时或者禁止中断时发生。</p>



<h4 id="短延迟">短延迟</h4>

<p>内核提供了三个可以处理短延迟的函数</p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">void</span> udelay(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> usecs);   <span class="hljs-comment">// 微秒</span>
<span class="hljs-keyword">void</span> ndelay(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> nsecs);   <span class="hljs-comment">// ns</span>
<span class="hljs-keyword">void</span> mdelay(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> msecs);   <span class="hljs-comment">// ms</span></code></pre>



<h4 id="scheduletimeout">schedule_timeout()</h4>

<p>更理想的执行延迟的方法是使用schedule_timeout()函数，该方法让延迟执行的任务睡眠到指定的延迟时间耗尽后再重新运行。但该方法也不能保证睡眠时间正好等于指定的延迟时间，只能尽量使睡眠时间接近指定的延迟时间。当指定的时间到期后，内核唤醒被延迟的任务并将其重新投入运行队列。</p>



<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-function">set_current_state(TASK_INTERRUPTIBLE)</span>;

<span class="hljs-function">schedule_timeout(seconds*HZ)</span></code></pre>



<h2 id="内存管理学习笔记">内存管理学习笔记</h2>



<h3 id="页">页</h3>

<p>页是内核管理内存的基本单位，内存管理单元（MMU，管理内存并把虚拟地址转化为物理地址的硬件）通常以页为单位进行处理，从虚拟内存的角度看，页就是最小单位。</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">struct</span> page{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;
    atomic_t _count;
    atomic_t _mapcoount;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">private</span>;
    <span class="hljs-keyword">struct</span> address_space *mapping;
    pgoff_t index;
    <span class="hljs-keyword">struct</span> list_head lru;
    <span class="hljs-keyword">void</span> *<span class="hljs-keyword">virtual</span>
}</code></pre>

<ul>
<li>flag成员：页的状态，比如页是不是脏的、是不是被锁在内存中。flag的每一位单独表示一种状态，也就是说最少可以表示32中状态（这取决于flag有多少位）</li>
<li>_count成员：存放页的引用计数，内核通过page_count()函数对该成员进行检查，若函数返回0则表示页空闲，若返回一个正整数则表示页正咋被使用。</li>
<li>virtual成员：是页的虚拟地址，通常情况下他就是页在虚拟内存中的地址，有些内存（比如 High Memory）并不会永久的映射到内核地址空间上，这事virtual成员的值为NULL</li>
<li>系统中每个页都被分配一个这样的结构体</li>
</ul>



<h3 id="区">区</h3>

<p>由于硬件的限制，内核并不能对所有的页一视同仁，比如有的硬件只能在特定的地址上执行DMA操作，有的结构其物理地址寻址范围大于虚拟地址寻址范围，导致部分内存不能永久性映射到内核空间上。</p>

<p>Linux主要使用了四个区将页分为不同的类型</p>

<pre><code>- ZONE_DMA：这个区包含用来执行DMA操作的页
- ZONE_DMA32：这个区与ZONE_DMA类似负责执行DMA操作，但是该区内的页只能被32位设备访问。
- ZONE_NORMAL：可以正常映射的页
- ZONE_HIGHMEM：这个区包含哪些不能被永久映射到内核地址空间的页。
</code></pre>

<p>分区是与体系结构相关的，有的体系结构中在所有的内存上执行DMA操作都没问题，那么ZONE_DMA就为空。同样，有的体系结构中不存在High Memory，即所有的内存都可以映射到内核空间上。</p>

<pre><code>- 在x86结构上，ISA设备不能在整个32位地址空间中执行DMA操作，ISA只能使用地址空间的前24位，即16M地址空间，所以ZONE_DMA在x86上包含的页都在0-16M的范围内。
- 在32位X86系统上，虚拟地址分为两部分，低地址开始的3G（0x0000 0000-0xC000 000）属于用户空间，高地址的1G（0xC000 0000 - 0xFFFF FFFF）属于内核空间。
- 对于内核空间来说，较低的896M（0xC000 0000 - 0xF7FF FFFF）可以直接映射到内核空间的物理地址上，剩下的128M（0xF800 0000 - 0xFFFF FFFF）根据需求映射成高地址。
</code></pre>

<p>某些分配必须从特定区中获取页，比如用于DMA的内存必须从ZONE_DMA区获取页，但是一般用途的内存可以从任何区内获取。需要注意的是，内存获取不能跨区进行，也就是说不能从两个区内获取页。</p>



<h3 id="获取页">获取页</h3>



<h4 id="获取页-1">获取页</h4>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">struct</span> page * alloc_pages(gfp_t gfp_mask, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> order);  
<span class="hljs-comment">// 返回page指针，该函数分配$2^order$个连续的物理页</span>

<span class="hljs-keyword">void</span>* page_address(<span class="hljs-keyword">struct</span> page *page);
<span class="hljs-comment">// 该函数返回当前所在的逻辑地址。</span>

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> __get_free_pages(gfp_t gfp_mask, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> order);
<span class="hljs-comment">// 该返回获取 $2^order$个页，并返回第一个页的逻辑地址</span>

<span class="hljs-keyword">struct</span> page * alloc_page(gfp_t gfp_mask);
<span class="hljs-comment">// 分配一个页,返回page指针</span>
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> __get_free_page(gfp_t gfp_mask);
<span class="hljs-comment">// 分配一个页，返回页的逻辑地址</span>

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> get_zeroed_page(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> gfp_mask);
<span class="hljs-comment">// 获取填充为0的页</span></code></pre>



<h4 id="释放页">释放页</h4>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">void</span> __free_pages(<span class="hljs-keyword">struct</span> page* page, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> order);
<span class="hljs-keyword">void</span> free_pages(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> order);
<span class="hljs-keyword">void</span> free_page(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr);</code></pre>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> page;

page = __get_free_pages(GFP_KERNEL, <span class="hljs-number">3</span>);
<span class="hljs-keyword">if</span>(!page){
    <span class="hljs-keyword">return</span> -ENOMEM;
}

<span class="hljs-comment">// ....</span>
<span class="hljs-comment">// ....</span>

free_pages(page,<span class="hljs-number">3</span>);</code></pre>



<h4 id="gfpmask标志">gfp_mask标志</h4>

<p>分配器标志可以分为三类：行为修饰符、区修饰符、类型。用于指定获得内存时的方式，包括怎么获取，从哪里获取等行为。</p>

<p>最常用的标志是GFP_KERNEL，这种分配可能会阻塞，该标志只能用在可以重新安排调度的进程上下文中（未被锁持有）。</p>

<p>GFP_ATOMIC标志表示不能睡眠的内存分配，如果当前的代码不能睡眠（如中断、软中断、tasklet等）那么可以用该标志获取内存。</p>

<p>GFP_NOIO表示分配内存时不会启动磁盘IO来帮助满足请求。</p>

<p>GFP_NOFS 表示它可能会启动磁盘IO，但是不会启动文件系统IO。</p>

<pre><code>在绝大多数代码中用到的标志要么是GFP_KERNEL，要么是GFP_ATOMIC。
- 进程上下文，可以睡眠 =&gt; GFP_KERNEL
- 进程上下文，不可以睡眠 =&gt; GFP_ATOMIC
- 中断、软中断、tasklet =&gt;  GFP_ATOMIC
- 用于DMA，可睡眠   =&gt;  GFP_DMA|GFP_KERNEL
- 用于DMA, 不可睡眠 =&gt; GFP_DMA|GFP_ATOMIC
</code></pre>



<h3 id="kmalloc-and-vmalloc">kmalloc() and vmalloc()</h3>

<p>kmalloc()函数用来获得指定字节数的连续内存，其函数声明如下：</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">void</span> * kmalloc(size_t size, gfp_t flags);
<span class="hljs-comment">// 该函数返回一个指向内存块的指针，其内存块至少为size字节大小</span>
<span class="hljs-comment">// 新分配的内存区域在物理上是连续的。</span>

<span class="hljs-keyword">void</span> kfree(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-comment">// 释放不需要的内存</span></code></pre>

<p>vmolloc()函数类似于kmalloc()，不过该函数分配的内存在虚拟地址上是连续，而在物理地址上不连续。</p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">void</span> * vmalloc(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size);
<span class="hljs-comment">// 分配size字节大小的内存，在逻辑上连续，物理地址不一定连续</span>

<span class="hljs-keyword">void</span> vfree(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * addr);
<span class="hljs-comment">// 释放不需要的虚拟内存</span></code></pre>

<p>由molloc()分配的内存在进程的虚拟地址上也是连续的，但是不能保证其在物理地址上连续。</p>

<p>大多数情况下，只由硬件需要得到物理地址连续的内存，因为硬件设备一般存在于内存管理单元之外，它根本不知道啥是虚拟内存。对于内核而言，所有的内存看起来都是逻辑上连续的。</p>

<p>尽管某些情况下才需要物理上连续的内存，但是内核一般是用kmalloc()函数的，因为vmalloc()为了把不连续的物理地址映射为连续的虚拟地址，还需要做额外的工作。只有在获得大块内存时才会用vmalloc()函数来分配。</p>



<h3 id="slab层">slab层</h3>

<p>为了便于数据频繁的分配和回收，编程人员常会用到空闲链表作为缓存，空闲链表中包含已经分配好的数据结构块，可以直接获得，节省了分配内存的步骤。</p>

<p>Linux内核提供了slab层，slab分配器扮演了通用数据结构缓存层的角色。</p>

<p>每种类型的对象都对应一个高速缓存，每个高速缓存被分为不同的slab，slab由一个或多个物理上连续的页组成。一般情况下，每个slab由一个页组成。每个slab都包含一些对象成员（被缓存的数据结构）。每个slab处于三种状态的一种：满，空，部分。一个满的slab没有空闲对象，都被占用。空的slab则所有对象都是空闲的。</p>

<p>高速缓存使用kmem_cache结构表示，其包含三个链表：slabs_full, slabs_partial, slabs_empty，这三个链表均存放于kmem_list3结构内。</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">struct</span> slab{
    <span class="hljs-keyword">struct</span> list_head    <span class="hljs-built_in">list</span>;       <span class="hljs-comment">// 满、空或部分满的链表</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>       colouroff;  <span class="hljs-comment">// slab着色偏移量</span>
    <span class="hljs-keyword">void</span>                *s_mem;     <span class="hljs-comment">// slab中的第一个对象</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>        inuse;      <span class="hljs-comment">// slab中已经分配的对象数</span>
    kmem_bufctl_t       <span class="hljs-built_in">free</span>;       <span class="hljs-comment">// 第一个空闲对象</span>
}</code></pre>

<p>slab描述符要么在slab之外另行分配，要么放下slab自身开始的地方。如果slab很小，或者slab内部有足够空间容纳slab描述符，那么描述符就放在slab里面。</p>



<h4 id="slab分配器接口">slab分配器接口</h4>

<p>一个新的高速缓存通过kmem_cache_create()函数类创建</p>



<pre class="prettyprint"><code class=" hljs oxygene">struct kmem_cache * kmem_cache_create( <span class="hljs-keyword">const</span> char *name,
                                        size_t size,
                                        size_t align,
                                        unsigned long <span class="hljs-keyword">flags</span>,
                                        void <span class="hljs-comment">(*ctor) (void*)</span>);</code></pre>

<p>第一个参数是字符串，存放缓存的名字，第二个变量使缓存中每个元素的大小，第三个参数是slab内第一个对象的偏移，确保页内的特定对齐，flags表示特定的标志。</p>

<pre><code>- SLAB_HWCACHE_ALIGN: 把一个slab内的所有对象按高速缓存行对齐
- SLAB_POISON: 使slab用已知的值（a5a5a5a5）填充slab
- SLAB_RED_ZONE: 这个标志导致slab层在已分配内存的周围插入红色警戒区。
- SLAB_PANIC: 这个标志当分配失败时提醒slab层。
- SLAB_CACHE_DMA: 这个标志命令slab层使用可以执行DMA的内存给slab分配空间。
</code></pre>

<p>最后一个参数ctor是构造函数，只有在新的页被追加到高速缓存时，这个函数才会被调用。实际上Linux内核的二高速缓存不使用构造函数。</p>

<p>要撤销一个高速缓存使用 kmem_cache_destroy()，调用该函数时要保证高速缓存中的所有页都是空，而且在调用该函数的过程中不能在访问该高速缓存。</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">int</span> kmem_cache_destroy(<span class="hljs-keyword">struct</span> kmem_cache *cachep)</code></pre>



<h5 id="缓存中分配与释放">缓存中分配与释放</h5>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">void</span> * kmem_cache_alloc(<span class="hljs-keyword">struct</span> kmem_cache *cachep, gfp_t flags);

<span class="hljs-keyword">void</span> kmem_cache_free(<span class="hljs-keyword">struct</span> kmem_cache * cachep, <span class="hljs-keyword">void</span> *objp);

<span class="hljs-comment">// slab分配器的使用</span>

<span class="hljs-comment">// 首先定义一个全局变量，存放指向高速缓存的指针</span>
<span class="hljs-keyword">struct</span> kmem_cache * task_struct_cachep;

<span class="hljs-comment">// 在内核初始化期间，创建高速缓存</span>
task_struct_cachep = kmem_cache_create(<span class="hljs-string">"task_struct"</span>,
                                        <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> task_struct),
                                        ARCH_MIN_TASKSTRUCT,
                                        SLAB_PANIC | SLAB_NOTRACK,
                                        <span class="hljs-literal">NULL</span>);


<span class="hljs-comment">//创建新的进程描述符</span>
<span class="hljs-keyword">struct</span> task_struct *tsk;
tsk = kmem_cache_alloc(task_struct_cachep,  GFP_KERNEL);
<span class="hljs-keyword">if</span>(!tsk)
    <span class="hljs-comment">//分配失败</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;

<span class="hljs-comment">//进程执行完后，释放缓存</span>
kmem_cache_free(task_struct_cachep, tsk);


<span class="hljs-comment">// 最后如果有需要的话，可以撤销该高速缓存</span>
<span class="hljs-keyword">int</span> err;
err = kmem_cache_destroy(task_struct_cachep);

<span class="hljs-keyword">if</span>(err)
    <span class="hljs-comment">//...</span>
    ;</code></pre>



<h2 id="虚拟文件系统">虚拟文件系统</h2>

<p>内核在它的底层文件系统系统接口上建立一个抽象层，该抽象层使Linux可以支持各种文件系统，即便他们在功能和行为上存在很大差异。</p>

<p>VFS抽象层定义了各个文件系统都支持的基本的、概念上的接口和结构数据。</p>



<h3 id="vfs对象及其数据结构">VFS对象及其数据结构</h3>

<p>VFS中有四个主要的对象类型：</p>

<ul>
<li>超级块：表示一个具体的已安装文件系统，包含文件的控制信息等内容。</li>
<li>索引点对象：代表一个具体的文件，包含文件的相关信息，比如文件大小、拥有者、创建时间等。</li>
<li>目录项对象：代表一个目录项，是路径的组成部分</li>
<li>文件对象：代表进程已经打开的文件，显然一个文件可以被多个进程打开，也就是说一个文件可能对应多个文件对象</li>
</ul>

<p>对于对象都存在对应的操作方法：</p>

<ul>
<li>super_operationss对象，包含内核针对特定文件系统所能调用的方法</li>
<li>inode_operations对象，包含内核针对特定文件所能调用的方法</li>
<li>dentry_operations对象，包含内核针对特定目录所能进行的操作</li>
<li>file_operations对象，其中进程针对已打开的文件所进行的操作</li>
</ul>



<h4 id="超级快对象-superblock">超级快对象 super_block</h4>

<p>各种文件系统都必须实现超级块对象，该对象用于存储特定文件系统的信息，通常对应于存放在磁盘特定扇区。</p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">struct</span> super_block {
    <span class="hljs-keyword">struct</span> list_head    s_list;     <span class="hljs-comment">/* Keep this first */</span>
    dev_t           s_dev;      <span class="hljs-comment">/* search index; _not_ kdev_t */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>       s_dirt;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>       s_blocksize_bits;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>       s_blocksize;
    loff_t          s_maxbytes; <span class="hljs-comment">/* Max file size */</span>
    <span class="hljs-keyword">struct</span> file_system_type *s_type;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> super_operations   *s_op;      <span class="hljs-comment">// 超级块操作方法</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> dquot_operations   *dq_op;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> quotactl_ops   *s_qcop;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> export_operations *s_export_op;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>       s_flags;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>       s_magic;
    <span class="hljs-keyword">struct</span> dentry       *s_root;
    <span class="hljs-keyword">struct</span> rw_semaphore s_umount;
    <span class="hljs-keyword">struct</span> mutex        s_lock;
    <span class="hljs-keyword">int</span>         s_count;
    <span class="hljs-keyword">int</span>         s_need_sync;
    atomic_t        s_active;
<span class="hljs-preprocessor">#ifdef CONFIG_SECURITY</span>
    <span class="hljs-keyword">void</span>                    *s_security;
<span class="hljs-preprocessor">#endif</span>
    <span class="hljs-keyword">struct</span> xattr_handler    **s_xattr;

    <span class="hljs-keyword">struct</span> list_head    s_inodes;   <span class="hljs-comment">/* all inodes */</span>
    <span class="hljs-keyword">struct</span> hlist_head   s_anon;     <span class="hljs-comment">/* anonymous dentries for (nfs) exporting */</span>
    <span class="hljs-keyword">struct</span> list_head    s_files;
    <span class="hljs-comment">/* s_dentry_lru and s_nr_dentry_unused are protected by dcache_lock */</span>
    <span class="hljs-keyword">struct</span> list_head    s_dentry_lru;   <span class="hljs-comment">/* unused dentry lru */</span>
    <span class="hljs-keyword">int</span>         s_nr_dentry_unused; <span class="hljs-comment">/* # of dentry on lru */</span>

    <span class="hljs-keyword">struct</span> block_device *s_bdev;
    <span class="hljs-keyword">struct</span> backing_dev_info *s_bdi;
    <span class="hljs-keyword">struct</span> mtd_info     *s_mtd;
    <span class="hljs-keyword">struct</span> list_head    s_instances;
    <span class="hljs-keyword">struct</span> quota_info   s_dquot;    <span class="hljs-comment">/* Diskquota specific options */</span>

    <span class="hljs-keyword">int</span>         s_frozen;
    wait_queue_head_t   s_wait_unfrozen;

    <span class="hljs-keyword">char</span> s_id[<span class="hljs-number">32</span>];              <span class="hljs-comment">/* Informational name */</span>

    <span class="hljs-keyword">void</span>            *s_fs_info; <span class="hljs-comment">/* Filesystem private info */</span>
    fmode_t         s_mode;

    <span class="hljs-comment">/* Granularity of c/m/atime in ns.
       Cannot be worse than a second */</span>
    u32        s_time_gran;

    <span class="hljs-comment">/*
     * The next field is for VFS *only*. No filesystems have any business
     * even looking at it. You had been warned.
     */</span>
    <span class="hljs-keyword">struct</span> mutex s_vfs_rename_mutex;    <span class="hljs-comment">/* Kludge */</span>

    <span class="hljs-comment">/*
     * Filesystem subtype.  If non-empty the filesystem type field
     * in /proc/mounts will be "type.subtype"
     */</span>
    <span class="hljs-keyword">char</span> *s_subtype;

    <span class="hljs-comment">/*
     * Saved mount options for lazy filesystems using
     * generic_show_options()
     */</span>
    <span class="hljs-keyword">char</span> *s_options;
};</code></pre>

<p>超级块对象中断s_op成员指向超级块的操作函数表，其形式如下，该结构体的每一项成员都是一个函数指针，</p>



<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-keyword">struct</span> super_operations {
    <span class="hljs-keyword">struct</span> inode *(*alloc_inode)(<span class="hljs-keyword">struct</span> super_block *sb);   <span class="hljs-comment">// 在给定的超级块下创建并初始化一个新的节点对象</span>
    <span class="hljs-keyword">void</span> (*destroy_inode)(<span class="hljs-keyword">struct</span> inode *);      <span class="hljs-comment">//释放给定的索引点</span>

    <span class="hljs-keyword">void</span> (*dirty_inode) (<span class="hljs-keyword">struct</span> inode *);       <span class="hljs-comment">// 索引节点脏（被修改）时调用此函数</span>
    <span class="hljs-keyword">int</span> (*write_inode) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> writeback_control *wbc);<span class="hljs-comment">//将给定索引节点写到磁盘</span>
    <span class="hljs-keyword">void</span> (*drop_inode) (<span class="hljs-keyword">struct</span> inode *);    <span class="hljs-comment">// 在最后一个指向索引节点的引用被释放后，VFS会调用该函数。VFS只需简单删除这个索引节点。</span>
    <span class="hljs-keyword">void</span> (*delete_inode) (<span class="hljs-keyword">struct</span> inode *);
    <span class="hljs-keyword">void</span> (*put_super) (<span class="hljs-keyword">struct</span> super_block *);
    <span class="hljs-keyword">void</span> (*write_super) (<span class="hljs-keyword">struct</span> super_block *);
    <span class="hljs-keyword">int</span> (*sync_fs)(<span class="hljs-keyword">struct</span> super_block *sb, <span class="hljs-keyword">int</span> wait);
    <span class="hljs-keyword">int</span> (*freeze_fs) (<span class="hljs-keyword">struct</span> super_block *);
    <span class="hljs-keyword">int</span> (*unfreeze_fs) (<span class="hljs-keyword">struct</span> super_block *);
    <span class="hljs-keyword">int</span> (*statfs) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> kstatfs *);
    <span class="hljs-keyword">int</span> (*remount_fs) (<span class="hljs-keyword">struct</span> super_block *, <span class="hljs-keyword">int</span> *, <span class="hljs-keyword">char</span> *);
    <span class="hljs-keyword">void</span> (*clear_inode) (<span class="hljs-keyword">struct</span> inode *);
    <span class="hljs-keyword">void</span> (*umount_begin) (<span class="hljs-keyword">struct</span> super_block *);

    <span class="hljs-keyword">int</span> (*show_options)(<span class="hljs-keyword">struct</span> seq_file *, <span class="hljs-keyword">struct</span> vfsmount *);
    <span class="hljs-keyword">int</span> (*show_stats)(<span class="hljs-keyword">struct</span> seq_file *, <span class="hljs-keyword">struct</span> vfsmount *);
<span class="hljs-preprocessor">#ifdef CONFIG_QUOTA</span>
    ssize_t (*quota_read)(<span class="hljs-keyword">struct</span> super_block *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span> *, size_t, loff_t);
    ssize_t (*quota_write)(<span class="hljs-keyword">struct</span> super_block *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, size_t, loff_t);
<span class="hljs-preprocessor">#endif</span>
    <span class="hljs-keyword">int</span> (*bdev_try_to_free_page)(<span class="hljs-keyword">struct</span> super_block*, <span class="hljs-keyword">struct</span> page*, gfp_t);
};</code></pre>



<h4 id="索引节点对象">索引节点对象</h4>

<p>索引节点对象包含了内核在操作文件或目录时需要的全部信息，其定义如下</p>



<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-keyword">struct</span> inode {
    <span class="hljs-keyword">struct</span> hlist_node   i_hash;
    <span class="hljs-keyword">struct</span> list_head    i_list;     <span class="hljs-comment">/* backing dev IO list */</span>
    <span class="hljs-keyword">struct</span> list_head    i_sb_list;
    <span class="hljs-keyword">struct</span> list_head    i_dentry;
    unsigned <span class="hljs-keyword">long</span>       i_ino;
    atomic_t        i_count;
    unsigned <span class="hljs-keyword">int</span>        i_nlink;
    uid_t           i_uid;
    gid_t           i_gid;
    dev_t           i_rdev;
    unsigned <span class="hljs-keyword">int</span>        i_blkbits;
    u64         i_version;
    loff_t          i_size;
<span class="hljs-preprocessor">#ifdef __NEED_I_SIZE_ORDERED</span>
    seqcount_t      i_size_seqcount;
<span class="hljs-preprocessor">#endif</span>
    <span class="hljs-keyword">struct</span> timespec     i_atime;
    <span class="hljs-keyword">struct</span> timespec     i_mtime;
    <span class="hljs-keyword">struct</span> timespec     i_ctime;
    blkcnt_t        i_blocks;
    unsigned <span class="hljs-keyword">short</span>          i_bytes;
    umode_t         i_mode;
    spinlock_t      i_lock; <span class="hljs-comment">/* i_blocks, i_bytes, maybe i_size */</span>
    <span class="hljs-keyword">struct</span> mutex        i_mutex;
    <span class="hljs-keyword">struct</span> rw_semaphore i_alloc_sem;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> inode_operations   *i_op;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> file_operations    *i_fop; <span class="hljs-comment">/* former -&gt;i_op-&gt;default_file_ops */</span>
    <span class="hljs-keyword">struct</span> super_block  *i_sb;
    <span class="hljs-keyword">struct</span> file_lock    *i_flock;
    <span class="hljs-keyword">struct</span> address_space    *i_mapping;
    <span class="hljs-keyword">struct</span> address_space    i_data;
<span class="hljs-preprocessor">#ifdef CONFIG_QUOTA</span>
    <span class="hljs-keyword">struct</span> dquot        *i_dquot[MAXQUOTAS];
<span class="hljs-preprocessor">#endif</span>
    <span class="hljs-keyword">struct</span> list_head    i_devices;
    union {
        <span class="hljs-keyword">struct</span> pipe_inode_info  *i_pipe;
        <span class="hljs-keyword">struct</span> block_device *i_bdev;
        <span class="hljs-keyword">struct</span> cdev     *i_cdev;
    };

    __u32           i_generation;

<span class="hljs-preprocessor">#ifdef CONFIG_FSNOTIFY</span>
    __u32           i_fsnotify_mask; <span class="hljs-comment">/* all events this inode cares about */</span>
    <span class="hljs-keyword">struct</span> hlist_head   i_fsnotify_mark_entries; <span class="hljs-comment">/* fsnotify mark entries */</span>
<span class="hljs-preprocessor">#endif</span>

<span class="hljs-preprocessor">#ifdef CONFIG_INOTIFY</span>
    <span class="hljs-keyword">struct</span> list_head    inotify_watches; <span class="hljs-comment">/* watches on this inode */</span>
    <span class="hljs-keyword">struct</span> mutex        inotify_mutex;  <span class="hljs-comment">/* protects the watches list */</span>
<span class="hljs-preprocessor">#endif</span>

    unsigned <span class="hljs-keyword">long</span>       i_state;
    unsigned <span class="hljs-keyword">long</span>       dirtied_when;   <span class="hljs-comment">/* jiffies of first dirtying */</span>

    unsigned <span class="hljs-keyword">int</span>        i_flags;

    atomic_t        i_writecount;
<span class="hljs-preprocessor">#ifdef CONFIG_SECURITY</span>
    <span class="hljs-keyword">void</span>            *i_security;
<span class="hljs-preprocessor">#endif</span>
<span class="hljs-preprocessor">#ifdef CONFIG_FS_POSIX_ACL</span>
    <span class="hljs-keyword">struct</span> posix_acl    *i_acl;
    <span class="hljs-keyword">struct</span> posix_acl    *i_default_acl;
<span class="hljs-preprocessor">#endif</span>
    <span class="hljs-keyword">void</span>            *i_private; <span class="hljs-comment">/* fs or device private pointer */</span>
};</code></pre>

<p>一个索引点代表文件系统中的一个文件，它也可以是设备或管道这样的特殊文件。要注意到的是，索引点仅当文件被访问时，才会在内存中创建。 </p>

<p>索引节点操作由结构inode_operations定义，如下所示</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">struct</span> inode_operations {
    <span class="hljs-keyword">int</span> (*create) (<span class="hljs-keyword">struct</span> inode *,<span class="hljs-keyword">struct</span> dentry *,<span class="hljs-keyword">int</span>, <span class="hljs-keyword">struct</span> nameidata *);
    <span class="hljs-comment">// VFS通过调用create()和open()来调用函数，从而为entry对象创建一个新的索引节点</span>

    <span class="hljs-keyword">struct</span> dentry * (*lookup) (<span class="hljs-keyword">struct</span> inode *,<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> nameidata *);
    <span class="hljs-comment">// 该函数在特定目录寻找索引节点</span>

    <span class="hljs-keyword">int</span> (*link) (<span class="hljs-keyword">struct</span> dentry *,<span class="hljs-keyword">struct</span> inode *,<span class="hljs-keyword">struct</span> dentry *);
    <span class="hljs-comment">// 该函数被系统调用link()调用，穿件硬链接。</span>

    <span class="hljs-keyword">int</span> (*unlink) (<span class="hljs-keyword">struct</span> inode * dir,<span class="hljs-keyword">struct</span> dentry *);
    <span class="hljs-comment">// 从目录dir中删除dentry指定的索引节点对象</span>

    <span class="hljs-keyword">int</span> (*symlink) (<span class="hljs-keyword">struct</span> inode *,<span class="hljs-keyword">struct</span> dentry *,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *);
    <span class="hljs-keyword">int</span> (*mkdir) (<span class="hljs-keyword">struct</span> inode *,<span class="hljs-keyword">struct</span> dentry *,<span class="hljs-keyword">int</span>);
    <span class="hljs-keyword">int</span> (*rmdir) (<span class="hljs-keyword">struct</span> inode *,<span class="hljs-keyword">struct</span> dentry *);
    <span class="hljs-keyword">int</span> (*mknod) (<span class="hljs-keyword">struct</span> inode *,<span class="hljs-keyword">struct</span> dentry *,<span class="hljs-keyword">int</span>,dev_t);
    <span class="hljs-keyword">int</span> (*rename) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> dentry *,
            <span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> dentry *);
    <span class="hljs-keyword">int</span> (*readlink) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">char</span> __user *,<span class="hljs-keyword">int</span>);
    <span class="hljs-keyword">void</span> * (*follow_link) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> nameidata *);
    <span class="hljs-keyword">void</span> (*put_link) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> nameidata *, <span class="hljs-keyword">void</span> *);
    <span class="hljs-keyword">void</span> (*truncate) (<span class="hljs-keyword">struct</span> inode *);
    <span class="hljs-keyword">int</span> (*permission) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">int</span>);
    <span class="hljs-keyword">int</span> (*check_acl)(<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">int</span>);
    <span class="hljs-keyword">int</span> (*setattr) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> iattr *);
    <span class="hljs-keyword">int</span> (*getattr) (<span class="hljs-keyword">struct</span> vfsmount *mnt, <span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> kstat *);
    <span class="hljs-keyword">int</span> (*setxattr) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *,size_t,<span class="hljs-keyword">int</span>);
    ssize_t (*getxattr) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">void</span> *, size_t);
    ssize_t (*listxattr) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">char</span> *, size_t);
    <span class="hljs-keyword">int</span> (*removexattr) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *);
    <span class="hljs-keyword">void</span> (*truncate_range)(<span class="hljs-keyword">struct</span> inode *, loff_t, loff_t);
    <span class="hljs-keyword">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">int</span> mode, loff_t offset,
              loff_t len);
    <span class="hljs-keyword">int</span> (*fiemap)(<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> fiemap_extent_info *, u64 start,
              u64 len);
};
</code></pre>



<h4 id="目录项">目录项</h4>

<p>VFS把目录当文件对待，所以路径 /bin/vi中，bin和vi都属于文件，路径中每个组成部分都有一个索引节点对象表示。</p>

<p>为了方便查找操作，VFS引入了目录项的概念，每个dentry代表路径中的一个特定部分，对于上面路径来说，/、bin、vi都是目录项对象。也就是说，路径的每一个部分都是目录项对象。</p>

<p>目录项由dentry结构表示：</p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">struct</span> dentry {
    atomic_t d_count;           <span class="hljs-comment">/* 使用计数 */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> d_flags;       <span class="hljs-comment">/* 目录项标识 protected by d_lock */</span>
    spinlock_t d_lock;          <span class="hljs-comment">/* 单目录项锁 per dentry lock */</span>
    <span class="hljs-keyword">int</span> d_mounted;              <span class="hljs-comment">/* 是登陆点的目录项吗 */</span>
    <span class="hljs-keyword">struct</span> inode *d_inode;      <span class="hljs-comment">/* 相关联的索引节点 Where the name belongs to - NULL is
                     * negative */</span>
    <span class="hljs-comment">/*
     * The next three fields are touched by __d_lookup.  Place them here
     * so they all fit in a cache line.
     */</span>
    <span class="hljs-keyword">struct</span> hlist_node d_hash;   <span class="hljs-comment">/* 散列表lookup hash list */</span>
    <span class="hljs-keyword">struct</span> dentry *d_parent;    <span class="hljs-comment">/* 父目录的目录项对象 parent directory */</span>
    <span class="hljs-keyword">struct</span> qstr d_name;         <span class="hljs-comment">/* 目录项的名称 */</span>

    <span class="hljs-keyword">struct</span> list_head d_lru;     <span class="hljs-comment">/* 未使用链表 LRU list */</span>
    <span class="hljs-comment">/*
     * d_child and d_rcu can share memory
     */</span>
    <span class="hljs-keyword">union</span> {
        <span class="hljs-keyword">struct</span> list_head d_child;   <span class="hljs-comment">/* 目录项内部形成的链表 child of parent list */</span>
        <span class="hljs-keyword">struct</span> rcu_head d_rcu;      <span class="hljs-comment">/* RCU加锁 */</span>
    } d_u;
    <span class="hljs-keyword">struct</span> list_head d_subdirs; <span class="hljs-comment">/* 子目录链表 our children */</span>
    <span class="hljs-keyword">struct</span> list_head d_alias;   <span class="hljs-comment">/* 索引点别名链表 inode alias list */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> d_time;       <span class="hljs-comment">/* 重置时间 used by d_revalidate */</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> dentry_operations *d_op; <span class="hljs-comment">/* 目录项操作指针 */</span>
    <span class="hljs-keyword">struct</span> super_block *d_sb;   <span class="hljs-comment">/* 文件的超级块 The root of the dentry tree */</span>
    <span class="hljs-keyword">void</span> *d_fsdata;         <span class="hljs-comment">/* 文件系统特有数据 fs-specific data */</span>

    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> d_iname[DNAME_INLINE_LEN_MIN];    <span class="hljs-comment">/* 短文件名 small names */</span>
};</code></pre>

<p>目录项状态有三种，被使用、未被使用、负状态。</p>

<p>一个被使用的目录项对应一个有效索引节点，表面该对象有一个或多个使用者。一个目录项处于使用状态意味它被VFS使用并且指向有效数据。</p>

<p>一个未被使用的目录项对应一个有效的索引节点，但是VFS当前并未使用它。该目录项依然指向一个有效的对象，而且被保留在缓存中一遍需要时使用它。</p>

<p>一个负目录项表示没有对应有效的索引节点，因为节点已经被删除了，或路径不在正确了，但是项目依然保留，以便快速解析以后的目录查找。</p>



<h4 id="目录项缓存">目录项缓存</h4>

<p>如果VFS层遍历路径名中所有的元素并将它们逐个解析成目录项对象，还要达到最深层次的目录，将是一件费力的事，所以内核将目录项对象保存在目录项缓存中（D-Cache）。</p>

<p>目录项缓存主要包括三个主要部分：</p>

<ul>
<li><p>“被使用的”目录项链表，由相关的索引节点中i_dentry成员所引出的目录项构成的链表。该链表通过索引节点对象中的i_dentry项连接相关的目录项对象，因为一个给定的索引节点可能有多个链接，所以就有可能有多个目录项对象，因此用一个链表来表示他们。 <br>
Lists of “used” dentries linked off their associated inode via the i_dentry field of <br>
the inode object. Because a given inode can have multiple links, there might be <br>
multiple dentry objects; consequently, a list is used.</p></li>
<li><p>“最近被使用的”目录项双向链表，该链表含有未被使用和负状态的目录项对象 <br>
A doubly linked “least recently used” list of unused and negative dentry objects.The <br>
list is inserted at the head, such that entries toward the head of the list are newer <br>
than entries toward the tail.When the kernel must remove entries to reclaim memory, the entries are removed from the tail; those are the oldest and presumably have <br>
the least chance of being used in the near future.</p></li>
<li><p>散列表和相应的散列函数用来快速地将给定路径解析为相关的目录项对象。 <br>
A hash table and hashing function used to quickly resolve a given path into the <br>
associated dentry object.</p></li>
</ul>



<h4 id="目录项操作">目录项操作</h4>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">struct</span> dentry_operations {
    <span class="hljs-keyword">int</span> (*d_revalidate)(<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> nameidata *);
    <span class="hljs-comment">/* 该函数判断目录项是否有效 */</span>

    <span class="hljs-keyword">int</span> (*d_hash) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> qstr *);
    <span class="hljs-comment">/* 为目录项生成散列值，当目录项需要加入散列表时，调用该函数 */</span>

    <span class="hljs-keyword">int</span> (*d_compare) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> qstr *, <span class="hljs-keyword">struct</span> qstr *);
    <span class="hljs-comment">/* 用来比较两个文件名字 */</span>

    <span class="hljs-keyword">int</span> (*d_delete)(<span class="hljs-keyword">struct</span> dentry *);
    <span class="hljs-comment">/* 当目录项d_count计数为0时，调用该函数 */</span>

    <span class="hljs-keyword">void</span> (*d_release)(<span class="hljs-keyword">struct</span> dentry *);
    <span class="hljs-comment">/*  当目录项将要被释放时，调用该函数 */</span>

    <span class="hljs-keyword">void</span> (*d_iput)(<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> inode *);
    <span class="hljs-comment">/*当一个目录项丢失了一个索引点时调用该函数 */</span>

    <span class="hljs-keyword">char</span> *(*d_dname)(<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">int</span>);
};
</code></pre>



<h3 id="文件对象">文件对象</h3>

<p>文件对象表示进程已经打开的文件，是已经打开的文件在内存中的表示。该对象有open()系统调用创建，有close()系统调用撤销。这些文件相关的调用在文件操作表中定义。多个进程可以打开同一个文件，所以一个文件可能存在多个文件对象。文件对象仅仅在进程观念上代表已经打开的文件，它所对应的目录项才代表已打开的文件。一个文件对应的文件对象不是唯一的，但是对应的索引节点和目录项是唯一的。</p>

<pre><code>The file object is the in-memory representation of an open file.The object (but not the physical file) is created in response to the open() system call and destroyed in response to the close() system call.All these file-related calls are actually methods defined in the file operations table. Because multiple processes can open and manipulate a file at the same time, there can be multiple file objects in existence for the same file.The file object merely represents a process’s view of an open file.The object points back to the dentry (which in turn points back to the inode) that actually represents the open file.The inode and dentry objects, of course, are unique.
</code></pre>



<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-keyword">struct</span> file {
    <span class="hljs-comment">/*
     * fu_list becomes invalid after file_free is called and queued via
     * fu_rcuhead for RCU freeing
     */</span>
    union {
        <span class="hljs-keyword">struct</span> list_head    fu_list;    <span class="hljs-comment">/* 文件对象链表 */</span>
        <span class="hljs-keyword">struct</span> rcu_head     fu_rcuhead; <span class="hljs-comment">/* 释放之后的RCU链表 */</span>
    } f_u;
    <span class="hljs-keyword">struct</span> path     f_path;             <span class="hljs-comment">/* 包含目录项 */</span>
<span class="hljs-preprocessor">#define f_dentry    f_path.dentry       </span>
<span class="hljs-preprocessor">#define f_vfsmnt    f_path.mnt</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> file_operations    *f_op;<span class="hljs-comment">/* 文件操作方法 */</span>
    spinlock_t      f_lock;  <span class="hljs-comment">/* f_ep_links, f_flags, no IRQ */</span>
    atomic_long_t       f_count;
    unsigned <span class="hljs-keyword">int</span>        f_flags;
    fmode_t         f_mode;
    loff_t          f_pos;
    <span class="hljs-keyword">struct</span> fown_struct  f_owner;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> cred   *f_cred;
    <span class="hljs-keyword">struct</span> file_ra_state    f_ra;

    u64         f_version;
<span class="hljs-preprocessor">#ifdef CONFIG_SECURITY</span>
    <span class="hljs-keyword">void</span>            *f_security;
<span class="hljs-preprocessor">#endif</span>
    <span class="hljs-comment">/* needed for tty driver, and maybe others */</span>
    <span class="hljs-keyword">void</span>            *private_data;

<span class="hljs-preprocessor">#ifdef CONFIG_EPOLL</span>
    <span class="hljs-comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span>
    <span class="hljs-keyword">struct</span> list_head    f_ep_links;
<span class="hljs-preprocessor">#endif /* #ifdef CONFIG_EPOLL */</span>
    <span class="hljs-keyword">struct</span> address_space    *f_mapping;
<span class="hljs-preprocessor">#ifdef CONFIG_DEBUG_WRITECOUNT</span>
    unsigned <span class="hljs-keyword">long</span> f_mnt_write_state;
<span class="hljs-preprocessor">#endif</span>
};</code></pre>



<h4 id="文件操作">文件操作</h4>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">struct</span> file_operations {
    <span class="hljs-keyword">struct</span> module *owner;
    loff_t (*llseek) (<span class="hljs-keyword">struct</span> file *, loff_t, <span class="hljs-keyword">int</span>);
    ssize_t (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">char</span> __user *, size_t, loff_t *);
    ssize_t (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *, size_t, loff_t *);
    ssize_t (*aio_read) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> iovec *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>, loff_t);
    ssize_t (*aio_write) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> iovec *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>, loff_t);
    <span class="hljs-keyword">int</span> (*readdir) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">void</span> *, filldir_t);
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> (*poll) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *);
    <span class="hljs-keyword">int</span> (*ioctl) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>);
    <span class="hljs-keyword">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>);
    <span class="hljs-keyword">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>);
    <span class="hljs-keyword">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);
    <span class="hljs-keyword">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);
    <span class="hljs-keyword">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, fl_owner_t <span class="hljs-keyword">id</span>);
    <span class="hljs-keyword">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);
    <span class="hljs-keyword">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">int</span> datasync);
    <span class="hljs-keyword">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">int</span> datasync);
    <span class="hljs-keyword">int</span> (*fasync) (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">int</span>);
    <span class="hljs-keyword">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">struct</span> file_lock *);
    ssize_t (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-keyword">int</span>, size_t, loff_t *, <span class="hljs-keyword">int</span>);
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> (*get_unmapped_area)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>);
    <span class="hljs-keyword">int</span> (*check_flags)(<span class="hljs-keyword">int</span>);
    <span class="hljs-keyword">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">struct</span> file_lock *);
    ssize_t (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, loff_t *, size_t, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>);
    ssize_t (*splice_read)(<span class="hljs-keyword">struct</span> file *, loff_t *, <span class="hljs-keyword">struct</span> pipe_inode_info *, size_t, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>);
    <span class="hljs-keyword">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">struct</span> file_lock **);
};</code></pre>



<h3 id="和文件系统相关的数据结构">和文件系统相关的数据结构</h3>

<p>除了几个VFS对象，内核还使用了另一些标准数据结构来管理文件系统的其他相关数据。第一个对象是file_system_type，用来描述特定文件系统类型，必须ext3,ext4等。第二个结构体是vfsmount，用来描述一个安装文件的实例。</p>

<p>因为Linux支持众多的文件系统，因此需要一个特殊结构来描述各种文件系统的功能和行为，也就是file_system_type</p>



<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">struct</span> file_system_type {
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *name;
    <span class="hljs-keyword">int</span> fs_flags;
    <span class="hljs-keyword">int</span> (*get_sb) (<span class="hljs-keyword">struct</span> file_system_type *, <span class="hljs-keyword">int</span>,
               <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *, <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">struct</span> vfsmount *);
    <span class="hljs-keyword">void</span> (*kill_sb) (<span class="hljs-keyword">struct</span> super_block *);
    <span class="hljs-keyword">struct</span> <span class="hljs-keyword">module</span> *owner;
    <span class="hljs-keyword">struct</span> file_system_type * next;
    <span class="hljs-keyword">struct</span> list_head fs_supers;

    <span class="hljs-keyword">struct</span> lock_class_key s_lock_key;
    <span class="hljs-keyword">struct</span> lock_class_key s_umount_key;

    <span class="hljs-keyword">struct</span> lock_class_key i_lock_key;
    <span class="hljs-keyword">struct</span> lock_class_key i_mutex_key;
    <span class="hljs-keyword">struct</span> lock_class_key i_mutex_dir_key;
    <span class="hljs-keyword">struct</span> lock_class_key i_alloc_sem_key;
};</code></pre>

<p>每个文件系统不管有多少个实例安装在系统中，还是根本没有安装到系统中，都只有一个file_system_type结构。</p>

<p>当文件系统被安装时，将有一个 vfsmount结构体在安装点被创建。</p>



<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-keyword">struct</span> vfsmount {
    <span class="hljs-keyword">struct</span> list_head mnt_hash;
    <span class="hljs-keyword">struct</span> vfsmount *mnt_parent;    <span class="hljs-comment">/* fs we are mounted on */</span>
    <span class="hljs-keyword">struct</span> dentry *mnt_mountpoint;  <span class="hljs-comment">/* dentry of mountpoint */</span>
    <span class="hljs-keyword">struct</span> dentry *mnt_root;    <span class="hljs-comment">/* root of the mounted tree */</span>
    <span class="hljs-keyword">struct</span> super_block *mnt_sb; <span class="hljs-comment">/* pointer to superblock */</span>
    <span class="hljs-keyword">struct</span> list_head mnt_mounts;    <span class="hljs-comment">/* list of children, anchored here */</span>
    <span class="hljs-keyword">struct</span> list_head mnt_child; <span class="hljs-comment">/* and going through their mnt_child */</span>
    <span class="hljs-keyword">int</span> mnt_flags;
    <span class="hljs-comment">/* 4 bytes hole on 64bits arches */</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mnt_devname;    <span class="hljs-comment">/* Name of device e.g. /dev/dsk/hda1 */</span>
    <span class="hljs-keyword">struct</span> list_head mnt_list;
    <span class="hljs-keyword">struct</span> list_head mnt_expire;    <span class="hljs-comment">/* link in fs-specific expiry list */</span>
    <span class="hljs-keyword">struct</span> list_head mnt_share; <span class="hljs-comment">/* circular list of shared mounts */</span>
    <span class="hljs-keyword">struct</span> list_head mnt_slave_list;<span class="hljs-comment">/* list of slave mounts */</span>
    <span class="hljs-keyword">struct</span> list_head mnt_slave; <span class="hljs-comment">/* slave list entry */</span>
    <span class="hljs-keyword">struct</span> vfsmount *mnt_master;    <span class="hljs-comment">/* slave is on master-&gt;mnt_slave_list */</span>
    <span class="hljs-keyword">struct</span> mnt_namespace *mnt_ns;   <span class="hljs-comment">/* containing namespace */</span>
    <span class="hljs-keyword">int</span> mnt_id;         <span class="hljs-comment">/* mount identifier */</span>
    <span class="hljs-keyword">int</span> mnt_group_id;       <span class="hljs-comment">/* peer group identifier */</span>
    <span class="hljs-comment">/*
     * We put mnt_count &amp; mnt_expiry_mark at the end of struct vfsmount
     * to let these frequently modified fields in a separate cache line
     * (so that reads of mnt_flags wont ping-pong on SMP machines)
     */</span>
    atomic_t mnt_count;
    <span class="hljs-keyword">int</span> mnt_expiry_mark;        <span class="hljs-comment">/* true if marked for expiry */</span>
    <span class="hljs-keyword">int</span> mnt_pinned;
    <span class="hljs-keyword">int</span> mnt_ghosts;
<span class="hljs-preprocessor">#ifdef CONFIG_SMP</span>
    <span class="hljs-keyword">int</span> __percpu *mnt_writers;
<span class="hljs-preprocessor">#else</span>
    <span class="hljs-keyword">int</span> mnt_writers;
<span class="hljs-preprocessor">#endif</span>
};</code></pre></div></body>
</html>
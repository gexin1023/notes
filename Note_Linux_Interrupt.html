<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>中断与中断处理</title>
</head>
<body>
<div id="wmd-preview" class="wmd-preview"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="8kpu" id="中断与中断处理">中断与中断处理</h1><div class="md-section-divider"></div><h2 data-anchor-id="xl4g" id="何为中断">何为中断？</h2><ul data-anchor-id="gk4d">
<li>一种由设备发向处理器的电信号</li>
<li>中断不与处理器时钟同步，随时可以发生，内核随时可能因为中断到来而被打断。</li>
<li>每一个中断都有唯一一个数字标志，称之为中断线（IRQ）</li>
<li>异常是由软件产生，与处理器时钟同步。</li>
</ul><div class="md-section-divider"></div><h2 data-anchor-id="g96a" id="中断处理程序">中断处理程序</h2><ul data-anchor-id="9rlj">
<li>由内核调用来响应中断</li>
<li>运行于中断上下文</li>
<li>中断的执行不可阻塞</li>
<li>中断处理分为两个部分，中断处理程序是上半部（top half），还有下半部（bottom halves）</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="zlsc" id="中断处理程序注册">中断处理程序注册</h3><ul data-anchor-id="wubz">
<li>中断处理程序是管理硬件驱动程序的组成部分，如果设备使用中断，其相应的驱动程序就会注册一个中断处理程序。</li>
<li>通过request_irq（）函数来注册中断处理程序</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="bm6k"><ol class="linenums"><li class="L0"><code><span class="kwd">int</span><span class="pln"> request_irq</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> irq</span><span class="pun">,</span></code></li><li class="L1"><code><span class="pln">        </span><span class="typ">irq_handler_t</span><span class="pln"> handler</span><span class="pun">,</span></code></li><li class="L2"><code><span class="pln">        </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> flags</span><span class="pun">,</span></code></li><li class="L3"><code><span class="pln">        count </span><span class="kwd">char</span><span class="pun">*</span><span class="pln"> name</span><span class="pun">,</span></code></li><li class="L4"><code><span class="pln">        </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln">dev</span><span class="pun">)</span></code></li></ol></pre><ul data-anchor-id="r22e">
<li>第一个参数irq表示要分配的中断号</li>
<li>第二个参数handler表示中断处理程序指针</li>
<li>第三个表示标志，可以为0、IRQF_DISABLE、IRQF_SAMPLE_RANDOM、IRQF_TIMER、IRQF_SHARED <br>
<ul><li><strong>IRQF_DISABLE</strong> 表示该中断处理期间，禁用所有其他中断</li>
<li><strong>IRQF_SAMPLE_RANDOM</strong> 这个设备产生的中断对内核熵池有贡献</li>
<li><strong>IRQF_TIMER</strong> 为系统定时器中断而准备的</li>
<li><strong>IRQF_SHARED</strong> 表示多个中断处理程序共享中断线。</li></ul></li>
<li>第四个参数name表示设备的文本表示</li>
<li><p>第五个参数dev用于共享中断线，dev提供唯一的标志信息。</p>

<p>需要注意的是，request_irq( )可能睡眠，因此不能再中断上下文或者其他不允许阻塞的代码中调用该函数。</p></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="1er5" id="中断处理程序释放">中断处理程序释放</h3><p data-anchor-id="e0ws">卸载驱动程序时，需要用<strong>free_irq（）</strong>注销相应的中断处理程序，并释放中断线。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ishe"><ol class="linenums"><li class="L0"><code><span class="pln">  </span><span class="kwd">void</span><span class="pln"> free_irq</span><span class="pun">(</span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> irq</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln">dev</span><span class="pun">);</span></code></li></ol></pre><p data-anchor-id="gowa">如果指定的中断线不是共享的，那么该函数删除处理程序的同时将禁用这条中断线。如果是共享的，只删除dev对应的中断处理程序。</p><div class="md-section-divider"></div><h3 data-anchor-id="cpi2" id="编写中断处理程序">编写中断处理程序</h3><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="cbta"><ol class="linenums"><li class="L0"><code><span class="kwd">static</span><span class="pln"> </span><span class="typ">irqreturn_t</span><span class="pln"> intr_handler</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> irq</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> dev</span><span class="pun">);</span></code></li></ol></pre><p data-anchor-id="mbyi">当一个给定的中断处理程序正在执行时，相应的中断线在所有的处理器上都会被屏蔽掉，以防止在同一条中断线上接受另一个新的中断。</p><div class="md-section-divider"></div><h2 data-anchor-id="rysf" id="中断上下文">中断上下文</h2><ul data-anchor-id="129m">
<li>当执行一个中断时，内核处于中断上下文。</li>
<li>中断上下文没有后备进程，不可以睡眠。</li>
<li>中断上下文有着严格的时间限制，因为其打断了其他代码（有可能打断了其他中断处理程序）。中断上下文中的 代码应该迅速简洁，尽量不要使用循环去处理繁重的工作。</li>
</ul><div class="md-section-divider"></div><h2 data-anchor-id="omr3" id="中断控制">中断控制</h2><p data-anchor-id="uf1v">Linux内核提供了一组接口用于控制机器上的中断状态</p><ul data-anchor-id="dit2">
<li>禁止和激活中断 <br>
用于禁止、激活当前处理器的本地中断，</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="v8a7"><ol class="linenums"><li class="L0"><code><span class="pln">local_irq_disable</span><span class="pun">();</span></code></li><li class="L1"><code><span class="pln">local_irqenable</span><span class="pun">();</span></code></li></ol></pre><ul data-anchor-id="uamj">
<li>禁止指定中断线</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="7vud"><ol class="linenums"><li class="L0"><code><span class="kwd">void</span><span class="pln"> disable_irq</span><span class="pun">(</span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> irq</span><span class="pun">);</span><span class="pln">         </span><span class="com">//禁止控制器上某一条中断线，函数只有在当前执行的所有处理程序完成后，才能返回 </span></code></li><li class="L1"><code><span class="kwd">void</span><span class="pln"> disable_irq_nosync</span><span class="pun">(</span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> irq</span><span class="pun">);</span><span class="pln">  </span><span class="com">//禁止控制器上某一条中断线，不会等待当前中断处理程序执行完毕。</span></code></li><li class="L2"><code><span class="kwd">void</span><span class="pln"> enable_irq</span><span class="pun">(</span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> irq</span><span class="pun">);</span><span class="pln">          </span><span class="com">//激活控制器上某一条中断线， </span></code></li><li class="L3"><code><span class="kwd">void</span><span class="pln"> synchronize_irq</span><span class="pun">(</span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> irq</span><span class="pun">);</span><span class="pln">     </span><span class="com">//等待下一个特定的中断处理程序退出</span></code></li></ol></pre><p data-anchor-id="8g6n">在一条中断线上，每次调用disable_irq_nosync()、disable_irq()，都需要调用一次enable_irq()，只有在enable_irq()完成了最后一次调用后，才完成了中断线的激活。</p><ul data-anchor-id="r5xi">
<li>这三个函数可以从中断或进程上下文中调用，而且不会睡眠。</li>
</ul></div>
</body>
</html>
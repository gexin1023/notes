<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>下半部笔记</title>
</head>
<body>
<div id="wmd-preview" class="wmd-preview"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="je0a" id="下半部笔记">下半部笔记</h1><hr><div class="md-section-divider"></div><h2 data-anchor-id="zltm" id="1-软中断">1. 软中断</h2><div class="md-section-divider"></div><h3 data-anchor-id="ohax" id="软中断实现">软中断实现</h3><p data-anchor-id="l4gx">软中断是在编译期间静态分配，其结构如下所示，结构中包含一个接受该结构体指针作为参数的action函数。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="7uwf"><ol class="linenums"><li class="L0"><code class="language-c"><span class="kwd">struct</span><span class="pln"> softirq_action</span><span class="pun">{</span></code></li><li class="L1"><code class="language-c"><span class="pln">    </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">(*</span><span class="pln">action</span><span class="pun">)(</span><span class="kwd">struct</span><span class="pln"> softirq_action </span><span class="pun">*);</span></code></li><li class="L2"><code class="language-c"><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="sxhx">在kernel/softirq.c中定义了一个包含32个结构体的数组，每个数组成员都是一个被注册的软中断，数组如下所示：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ib0e"><ol class="linenums"><li class="L0"><code class="language-c"><span class="kwd">static</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> softirq_action softirq_vec</span><span class="pun">[</span><span class="pln">NR_SOFTIRQS</span><span class="pun">];</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="t4y8" id="软中断处理程序">软中断处理程序</h3><p data-anchor-id="d4ye">软中断处理函数action原型如下：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="h89d"><ol class="linenums"><li class="L0"><code class="language-c"><span class="kwd">void</span><span class="pln"> siftirq_handler</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> softirq_action </span><span class="pun">*);</span></code></li></ol></pre><p data-anchor-id="1zr3">内核通过如下的方式调用软中断处理函数：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="7p3j"><ol class="linenums"><li class="L0"><code class="language-c"><span class="pln">my_softirq</span><span class="pun">-&gt;</span><span class="pln">action</span><span class="pun">(</span><span class="pln">my_softirq</span><span class="pun">);</span></code></li></ol></pre><p data-anchor-id="kc77">软中断不会抢占其他软中断，唯一可以抢占软中断的是中断处理程序。</p><div class="md-section-divider"></div><h3 data-anchor-id="fwwu" id="软中断的执行">软中断的执行</h3><p data-anchor-id="h3v6">一个注册的软中断必须在被标记后才会被执行，软中断被唤起后，要在 do_softirq() 中执行，在do_softirq()函数中，遍历执行每一个被标记的软中断,如下所示：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="bsvz"><ol class="linenums"><li class="L0"><code class="language-c"><span class="pln">u32 pending</span><span class="pun">;</span></code></li><li class="L1"><code class="language-c"><span class="com">//pending表示32位的标志，用来标记32个软中断，若位设置为1说明该位对应的软中断唤起。</span></code></li><li class="L2"><code class="language-c"><span class="pln">pending </span><span class="pun">=</span><span class="pln"> local_softirq_pending</span><span class="pun">();</span></code></li><li class="L3"><code class="language-c"></code></li><li class="L4"><code class="language-c"><span class="kwd">if</span><span class="pun">(</span><span class="pln">pending</span><span class="pun">){</span></code></li><li class="L5"><code class="language-c"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> softirq_action </span><span class="pun">*</span><span class="pln">h</span><span class="pun">;</span></code></li><li class="L6"><code class="language-c"></code></li><li class="L7"><code class="language-c"><span class="pln">    set_softirq_pending</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="com">//重设置待处理的标志</span></code></li><li class="L8"><code class="language-c"></code></li><li class="L9"><code class="language-c"><span class="pln">    h </span><span class="pun">=</span><span class="pln"> softirq_vec</span><span class="pun">;</span></code></li><li class="L0"><code class="language-c"><span class="pln">    </span><span class="kwd">do</span><span class="pun">{</span></code></li><li class="L1"><code class="language-c"><span class="pln">        </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">pending</span><span class="pun">&amp;</span><span class="lit">1</span><span class="pun">)</span></code></li><li class="L2"><code class="language-c"><span class="pln">            h</span><span class="pun">-&gt;</span><span class="pln">action</span><span class="pun">(</span><span class="pln">h</span><span class="pun">);</span></code></li><li class="L3"><code class="language-c"><span class="pln">        h</span><span class="pun">++;</span></code></li><li class="L4"><code class="language-c"><span class="pln">        pending</span><span class="pun">&gt;&gt;</span><span class="lit">1</span><span class="pun">;</span></code></li><li class="L5"><code class="language-c"><span class="pln">    </span><span class="pun">}</span><span class="kwd">while</span><span class="pun">(</span><span class="pln">pending</span><span class="pun">);</span></code></li><li class="L6"><code class="language-c"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="boji" id="软中断的使用">软中断的使用</h3><div class="md-section-divider"></div><h4 data-anchor-id="iy27" id="1分配索引">1）分配索引</h4><p data-anchor-id="dcha">在编译期间，通过在中定义枚举类型来声明软中断，如下所示，其中软中断按照优先高低自上而下，新插入新的软中断时需要根据想要的优先级插入相应位置。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="cbdw"><ol class="linenums"><li class="L0"><code class="language-c"><span class="kwd">enum</span></code></li><li class="L1"><code class="language-c"><span class="pun">{</span></code></li><li class="L2"><code class="language-c"><span class="pln">    HI_SOFTIRQ</span><span class="pun">=</span><span class="lit">0</span><span class="pun">,</span><span class="pln">       </span><span class="com">//优先级高的tasklet</span></code></li><li class="L3"><code class="language-c"><span class="pln">    TIMER_SOFTIRQ</span><span class="pun">,</span></code></li><li class="L4"><code class="language-c"><span class="pln">    NET_TX_SOFTIRQ</span><span class="pun">,</span></code></li><li class="L5"><code class="language-c"><span class="pln">    NET_RX_SOFTIRQ</span><span class="pun">,</span></code></li><li class="L6"><code class="language-c"><span class="pln">    BLOCK_SOFTIRQ</span><span class="pun">,</span></code></li><li class="L7"><code class="language-c"><span class="pln">    BLOCK_IOPOLL_SOFTIRQ</span><span class="pun">,</span></code></li><li class="L8"><code class="language-c"><span class="pln">    TASKLET_SOFTIRQ</span><span class="pun">,</span><span class="pln">    </span><span class="com">//正常优先级的tasklet</span></code></li><li class="L9"><code class="language-c"><span class="pln">    SCHED_SOFTIRQ</span><span class="pun">,</span></code></li><li class="L0"><code class="language-c"><span class="pln">    HRTIMER_SOFTIRQ</span><span class="pun">,</span></code></li><li class="L1"><code class="language-c"><span class="pln">    RCU_SOFTIRQ</span><span class="pun">,</span><span class="pln">    </span><span class="com">/* Preferable RCU should always be the last softirq */</span></code></li><li class="L2"><code class="language-c"></code></li><li class="L3"><code class="language-c"><span class="pln">    NR_SOFTIRQS</span></code></li><li class="L4"><code class="language-c"><span class="pun">};</span></code></li></ol></pre><div class="md-section-divider"></div><h4 data-anchor-id="io5u" id="2注册处理程序">2）注册处理程序</h4><p data-anchor-id="yqnj">可以通过open_softirq(）函数注册软中断处理程序，两个参数：软中断索引号、处理函数。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="l4n2"><ol class="linenums"><li class="L0"><code class="language-c"><span class="pln">open_softirq</span><span class="pun">(</span><span class="pln">NET_RX_SOFTIRQ</span><span class="pun">,</span><span class="pln"> net_tx_action</span><span class="pun">);</span></code></li></ol></pre><p data-anchor-id="3ppm">软中断处理程序执行时候，允许相应中断，但不能自己休眠。 <br>
在一个处理器运行时候，当前处理器上软中断被禁止。</p><div class="md-section-divider"></div><h4 data-anchor-id="f71z" id="3触发中断">3）触发中断</h4><p data-anchor-id="u0lx">raise_softirq()函数可以实现软中断设置为挂起待执行，该函数在运行之前需要先禁止中断，触发后再恢复原来的状态。如果中断本来就已经被禁止，可以采用raise_softirq_irqoff()函数去唤醒中断。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="u6bf"><ol class="linenums"><li class="L0"><code class="language-c"><span class="pln">raise_softirq</span><span class="pun">(</span><span class="pln">NET_RX_SOFTIRQ</span><span class="pun">)；</span><span class="com">//需要在使用前关中断，然后再恢复。</span></code></li><li class="L1"><code class="language-c"></code></li><li class="L2"><code class="language-c"><span class="pln">raise_softirq_irqoff</span><span class="pun">(</span><span class="pln">NET_RX_SOFTIRQ</span><span class="pun">);</span><span class="com">//适用于中断本来就已经被禁止的情况</span></code></li></ol></pre><div class="md-section-divider"></div><h2 data-anchor-id="u8a0" id="2tasklet">2.tasklet</h2><pre data-anchor-id="h66f"><code>    tasklet是在软中断基础上实现的，相当于对软中断中的HI_SOFTIRQ、TASKLET_SOFTIRQ的更改，将tasklet链表加入到以上两个软中断的处理函数中执行。
    通常情况下，我们使用tasklet而不是软中断，使用软中断的情况屈指可数。
</code></pre><div class="md-section-divider"></div><h3 data-anchor-id="54eg" id="tasklet实现">tasklet实现</h3><div class="md-section-divider"></div><h4 data-anchor-id="mi3r" id="tasklet结构">tasklet结构</h4><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="s0ho"><ol class="linenums"><li class="L0"><code class="language-cpp"><span class="kwd">struct</span><span class="pln"> tasklet_struct</span><span class="pun">{</span></code></li><li class="L1"><code class="language-cpp"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> tasklet_struct </span><span class="pun">*</span><span class="pln">next</span><span class="pun">;</span><span class="pln">    </span><span class="com">//链表中下一个tasklet</span></code></li><li class="L2"><code class="language-cpp"><span class="pln">    </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> state</span><span class="pun">;</span><span class="pln">            </span><span class="com">//tasklet状态</span></code></li><li class="L3"><code class="language-cpp"><span class="pln">    </span><span class="typ">atomic_t</span><span class="pln"> count</span><span class="pun">;</span><span class="pln">                 </span><span class="com">//原子操作的计数器</span></code></li><li class="L4"><code class="language-cpp"><span class="pln">    </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">(*</span><span class="pln">func</span><span class="pun">)(</span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">long</span><span class="pun">);</span><span class="pln">    </span><span class="com">//tasklet处理函数</span></code></li><li class="L5"><code class="language-cpp"><span class="pln">    </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> data</span><span class="pun">;</span><span class="pln">             </span><span class="com">//给处理函数的参数</span></code></li><li class="L6"><code class="language-cpp"><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="1yat">结构体重state成员，可以取0、TASKLET_STATE_RUN、TASKLET_STATE_SCHED。 <br>
    TASKLET_STATE_RUN-&gt;正在运行 <br>
    TASKLET_STATE_SCHED-&gt;已被调度</p><div class="md-section-divider"></div><h4 data-anchor-id="ata7" id="调度">调度</h4><p data-anchor-id="0qtf">调度相当于将未调度的tasklet结构添加到两个链表结构：tasklet_vec(普通优先级)、tasklet_hi_vec(高优先级)。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="zkp9"><ol class="linenums"><li class="L0"><code class="language-cpp"><span class="pln">TASKLET_STATE_SCHED</span><span class="pun">();</span><span class="pln"> </span><span class="com">//tasklet调度函数</span></code></li><li class="L1"><code class="language-cpp"></code></li><li class="L2"><code class="language-cpp"><span class="com">/*</span></code></li><li class="L3"><code class="language-cpp"><span class="com"> * 检查tasklet状态是否为TASKLET_STATE_SCHED，是的话已被调度，直接返回</span></code></li><li class="L4"><code class="language-cpp"><span class="com"> * 调用 __TASKLET_STATE_SCHED()函数</span></code></li><li class="L5"><code class="language-cpp"><span class="com"> * 保存中断状态，然后禁止中断状态</span></code></li><li class="L6"><code class="language-cpp"><span class="com"> * 将被调用的tasklet添加到tasklet链表</span></code></li><li class="L7"><code class="language-cpp"><span class="com"> * 唤醒软中断HI_SOFTIRQ或者TASKLET_SOFTIRQ</span></code></li><li class="L8"><code class="language-cpp"><span class="com"> * 恢复中断状态并返回</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="4f1o" id="使用tasklet">使用tasklet</h3><div class="md-section-divider"></div><h4 data-anchor-id="5d1o" id="1-声明自己的tasklet">1) 声明自己的tasklet</h4><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="sj0g"><ol class="linenums"><li class="L0"><code class="language-CPP"><span class="pln">DECLEAR_TASKLET</span><span class="pun">(</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> func</span><span class="pun">,</span><span class="pln"> data</span><span class="pun">)</span><span class="pln">   </span><span class="com">//声明后tasklet处于激活状态</span></code></li><li class="L1"><code class="language-CPP"><span class="pln">DECLEAR_TASKLET_DISABLE</span><span class="pun">(</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> func</span><span class="pun">,</span><span class="pln"> data</span><span class="pun">)</span><span class="com">//声明后tasklet处于禁止状态</span></code></li></ol></pre><div class="md-section-divider"></div><h4 data-anchor-id="cjtg" id="2-编写tasklet处理程序">2） 编写tasklet处理程序</h4><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="hovl"><ol class="linenums"><li class="L0"><code><span class="kwd">void</span><span class="pln"> tasklet_handler</span><span class="pun">(</span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> data</span><span class="pun">)</span></code></li></ol></pre><p data-anchor-id="mdmf">因为tasklet是靠软中断实现的，因此不能睡眠，也就是说在tasklet处理函数中不能使用信号量或者其他阻塞式函数。</p><div class="md-section-divider"></div><h4 data-anchor-id="lbt8" id="3调度自己的tasklet">3)调度自己的tasklet</h4><p data-anchor-id="yl1e">我们可以通过tasklet_schedule()函数并传递给他相应的tasklet指针来调度，如下所示：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="v3cc"><ol class="linenums"><li class="L0"><code><span class="pln">tasklet_schedule</span><span class="pun">(&amp;</span><span class="pln">mytasklet</span><span class="pun">);</span><span class="pln"> </span><span class="com">//将tasklet指针传过去，来调度</span></code></li></ol></pre><p data-anchor-id="f4o1"><strong>要注意：tasklet总在调度他的处理器上执行。</strong></p><div class="md-section-divider"></div><h2 data-anchor-id="62p9" id="工作队列">工作队列</h2><p data-anchor-id="zqs4">工作队列可以把工作推后，交由一个内个线程去执行，这个下半部分总是会在进程上下文中执行。</p><div class="md-section-divider"></div><h3 data-anchor-id="mrq2" id="实现">实现</h3><p data-anchor-id="kmn0">工作队列最基本的是表现形式是把需要推后执行的任务交给特定的通用线程（工作队列也可以通过驱动程序创建工作者线程来处理推后工作，但是多数情况直接采用系统缺省的工作者线程来做推后工作）</p><div class="md-section-divider"></div><h4 data-anchor-id="pdpz" id="数据结构">数据结构</h4><p data-anchor-id="nwni">1） 表示线程的数据结构</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="s4ni"><ol class="linenums"><li class="L0"><code><span class="kwd">struct</span><span class="pln"> workqueue_struct</span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> ypu_workqueue_struct cpu_wq</span><span class="pun">[</span><span class="pln">NR_CPUS</span><span class="pun">];</span><span class="com">//数组每一项对应一个处理器</span></code></li><li class="L2"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> list_head list</span><span class="pun">;</span></code></li><li class="L3"><code><span class="pln">    </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">name</span><span class="pun">;</span></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">int</span><span class="pln"> singlethread</span><span class="pun">;</span></code></li><li class="L5"><code><span class="pln">    </span><span class="kwd">int</span><span class="pln"> freezeable</span><span class="pun">;</span></code></li><li class="L6"><code><span class="pln">    </span><span class="kwd">int</span><span class="pln"> rt</span><span class="pun">;</span></code></li><li class="L7"><code><span class="pun">}</span></code></li><li class="L8"><code><span class="kwd">struct</span><span class="pln"> cpu_workqueue_struct</span><span class="pun">{</span></code></li><li class="L9"><code><span class="pln">    </span><span class="typ">spinlock_t</span><span class="pln"> </span><span class="kwd">lock</span><span class="pun">;</span><span class="com">// 锁来保护这种结构</span></code></li><li class="L0"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> list_head worklist</span><span class="pun">;</span><span class="com">//工作列表</span></code></li><li class="L1"><code><span class="pln">    </span><span class="typ">wait_queue_head_t</span><span class="pln"> more_work</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> workqueue_struct </span><span class="pun">*</span><span class="pln"> wq</span><span class="pun">;</span><span class="pln">   </span><span class="com">//  关联工作队列结构</span></code></li><li class="L3"><code><span class="pln">    </span><span class="typ">task_t</span><span class="pln"> </span><span class="pun">*</span><span class="pln">thread</span><span class="pun">;</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="6jxo">注意：每一个工作者类型都关联一个自己的workqueue_struct.在该结构体里给每一个处理器（内的工作者线程）分配一个cpu_workqueue_struct。</p><p data-anchor-id="rfqz">2) 表示工作的数据结构</p><p data-anchor-id="r0rp">所有的工作者线程都是通过普通的内核线程实现的，他们都执行worker_thread()函数。在他们初始化完成以后，每个函数执行一个死循环并进入休眠，当有操作被传入队列里的时候，线程就会被唤醒，以执行这些操作。</p><p data-anchor-id="pzha">工作用work_struct结构体表示：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="i93z"><ol class="linenums"><li class="L0"><code><span class="pln">  </span><span class="kwd">struct</span><span class="pln"> work_struct</span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">        </span><span class="typ">atomic_long_t</span><span class="pln"> data</span><span class="pun">;</span><span class="pln"> </span><span class="com">//64位原子操作整数</span></code></li><li class="L2"><code><span class="pln">        </span><span class="kwd">struct</span><span class="pln"> list_head enty</span><span class="pun">;</span></code></li><li class="L3"><code><span class="pln">        </span><span class="typ">work_func_t</span><span class="pln"> func</span><span class="pun">;</span></code></li><li class="L4"><code><span class="pln">  </span><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="n350">这些结构体被连成链表，在每个处理器上的每种类型的队列都对应一个这样的链表。</p><div class="md-section-divider"></div><h3 data-anchor-id="nqjh" id="使用工作队列">使用工作队列</h3><div class="md-section-divider"></div><h4 data-anchor-id="z4gd" id="1创建推后的工作">1）创建推后的工作</h4><p data-anchor-id="0o2g">首先需要做的是创建一些需要推后完成的实际工作，通过宏DECLEAR_WORK在编译时静态创建结构体，如下所示：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="q1pj"><ol class="linenums"><li class="L0"><code><span class="pln">DECLEAR_WORK</span><span class="pun">(</span><span class="pln">name</span><span class="pun">;</span><span class="pln"> </span><span class="kwd">void</span><span class="pun">(*</span><span class="pln">func</span><span class="pun">)(</span><span class="kwd">void</span><span class="pun">*),</span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> data</span><span class="pun">);</span></code></li><li class="L1"><code><span class="com">//这样会静态的创建一个名为name,处理函数为func，参数为data的结构体。</span></code></li></ol></pre><p data-anchor-id="vq7e">也可以在运行时通过指针创建一个工作，如下所示：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="43pi"><ol class="linenums"><li class="L0"><code><span class="pln">INIT_WORK</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> work_struct </span><span class="pun">*</span><span class="pln">work</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">void</span><span class="pun">(*</span><span class="pln">func</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln">data</span><span class="pun">);</span></code></li><li class="L1"><code><span class="com">//动态初始化一个由work指向的工作</span></code></li></ol></pre><div class="md-section-divider"></div><h4 data-anchor-id="zt3v" id="2工作队列处理函数">2）工作队列处理函数</h4><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="g3fh"><ol class="linenums"><li class="L0"><code><span class="kwd">void</span><span class="pln"> work_handler</span><span class="pun">(</span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln">data</span><span class="pun">);</span><span class="com">//工作队列处理函数原型</span></code></li></ol></pre><p data-anchor-id="npd9">这个函数会有工作者线程执行，因此函数运行于进程上下文中，默认情况下，允许相应中断，不能持有任和锁。 <br>
<strong>需要注意的是，尽管操作函数运行于进程上下文中，但是他不能访问用户空间。</strong></p><div class="md-section-divider"></div><h4 data-anchor-id="pf30" id="3对工作进行调度">3）对工作进行调度</h4><p data-anchor-id="z4cc">可以通过调用函数schedule_work() 把处理函数交给缺省的events工作线程</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="kgtv"><ol class="linenums"><li class="L0"><code><span class="pln">schedule_work</span><span class="pun">(&amp;</span><span class="pln">work</span><span class="pun">);</span></code></li></ol></pre><p data-anchor-id="j7jz">work马上就会被调度，一旦其所在的处理器上的工作者线程被唤醒，他就会被执行。 <br>
若不想work马上就工作，二十希望他进行一段延迟再执行，可以通过：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="r5vo"><ol class="linenums"><li class="L0"><code><span class="str">`schedule_delay_work(&amp;work, delay);</span></code></li><li class="L1"><code><span class="str">//此时，直到delay的节拍时钟用完之后才会执行work</span></code></li></ol></pre><div class="md-section-divider"></div><h4 data-anchor-id="aht4" id="4刷新操作">4）刷新操作</h4><p data-anchor-id="szh8">进入队列的工作会在工作者线程的下一次被唤醒时候执行，在继续下一步工作之前，需要保证一些操作已经执行完毕。对于模块来说这一点很重要，在卸载之前，他可能需要调用以下函数。而在内核部分，为了防止竞争条件的出现，也可能需要确保不再持有处理工作。</p><p data-anchor-id="yrmd">出于以上目的，内核准备了一个用于刷新指定工作队列的函数</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="xf7w"><ol class="linenums"><li class="L0"><code><span class="kwd">void</span><span class="pln"> flush_schedule_work</span><span class="pun">(</span><span class="kwd">void</span><span class="pun">);</span></code></li></ol></pre><p data-anchor-id="u9rz">函数会一直等待，直到队列中所有对象都被执行以后才会返回。</p><div class="md-section-divider"></div><h4 data-anchor-id="wd4s" id="5创建新的工作队列">5）创建新的工作队列</h4><p data-anchor-id="x5ed">如果缺省的队列不能满足你的工作要求，需要创建新的工作队列与相应的工作者进程。由于这么做会在每个处理器上都创建一个工作者线程，所以只有在你明确了必须要自己创建一套线程来提高性能的情况下再创建自己的额工作队列。</p><p data-anchor-id="9q0x">这部分用的情况较少，需要的话再细看。</p></div>
</body>
</html>